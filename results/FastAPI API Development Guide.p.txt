1 S T  E D I T I O N
Develop high-performance APIs and web applications 
with Python
FastAPI Cookbook
GIUNIO DE LUCA, PHD
Foreword by Antonio Ferraro, MSC Computer Science, Business Owner
FastAPI Cookbook
Develop high-performance APIs and web applications 
with Python
Giunio De Luca
FastAPI Cookbook
Copyright © 2024 Packt Publishing
All rights reserved. No part of this book may be reproduced, stored in a retrieval system, or transmitted 
in any form or by any means, without the prior written permission of the publisher, except in the case 
of brief quotations embedded in critical articles or reviews.
The author acknowledges the use of cutting-edge AI, such as ChatGPT, with the sole aim of enhancing 
the language and clarity within the book, thereby ensuring a smooth reading experience for readers. 
It’s important to note that the content itself has been crafted by the author and edited by a professional 
publishing team. 
Every effort has been made in the preparation of this book to ensure the accuracy of the information 
presented. However, the information contained in this book is sold without warranty, either express 
or implied. Neither the author, nor Packt Publishing or its dealers and distributors, will be held liable 
for any damages caused or alleged to h
To my dear nephew, Marco.
You bring endless joy to our lives. I wish you a future filled with love, growth, and happiness. 
May you always find success and fulfillment in everything you do.
– Giunio De Luca
Foreword
Having worked alongside Giunio for over a year, I can confidently say that his expertise and passion 
for Python development are evident in every line of code he produces. I affirm this with no shadow of 
a doubt, as I am a developer with over 30 years of experience across several countries and prominent 
industries, including Microsoft, NATO, and IBM.
We naturally became friends due to our mutual respect and shared interests, both professional and 
personal. Giunio stood out in our team at Coreso, one of the European Regional Coordination Centers 
for high-voltage electricity flows. He has an impressive academic background coupled with extensive 
international experience. What truly sets him apart, however, is his deep and thorough understanding 
of Python and FastAPI. Giunio’s code is not only functional but also exceptionally clean and clear—a 
hallmark of a skilled developer, or in other words, a subject matter expert.
Beyond his technical prowess, Giunio possesses a quali
Contributors
About the author
Giunio De Luca is a software engineer with over 10 years of experience in fields such as physics, 
sports, and administration. He graduated in industrial engineering from the University of Basilicata 
and holds a PhD in numerical simulations from Paris-Saclay University. His work spans developing 
advanced algorithms, creating sports analytics applications, and improving administrative processes. 
As an independent consultant, he collaborates with research labs, government agencies, and start-ups 
across Europe. He also supports coding education in schools and universities through workshops, 
lectures, and mentorship programs, inspiring the next generation of software engineers with his 
expertise and dedication.
With heartfelt gratitude, I thank my family and my loved ones for their continuous encouragement. 
I am also thankful to all my employers who have believed in my expertise, and my current clients 
and colleagues who keep trusting my work and provi
About the reviewer
Adarsh Divakaran is an experienced backend developer with expertise in architecting, building, and 
deploying APIs, primarily using Python. He is the co-founder of Digievo Labs, a global technology 
firm. He loves reading all sorts of Python content and runs a newsletter, Python in the Wild, showcasing 
Python concepts and examples from open source projects. Adarsh also speaks at global Python 
conferences, including PyCascades, EuroPython, and FlaskCon.
Preface
xv
1
First Steps with FastAPI
1
Technical requirements
2
Setting up your development 
environment
2
Getting ready
3
How to do it...
4
Creating a new FastAPI project
6
Getting ready
6
How to do it...
6
There’s more...
8
See also
8
Understanding FastAPI basics
8
How to do it…
9
See also
11
Defining your first API endpoint
12
Getting ready
12
How to do it...
12
How it works…
13
Working with path 
and query parameters
13
Getting ready
14
How to do it…
14
How it works…
15
See also
15
Defining and using request 
and response models
15
Getting ready
16
How to do it...
16
See also
18
Handling errors and exceptions
19
How to do it…
19
There’s more…
20
See also
22
2
Working with Data
23
Technical requirements
24
Setting up SQL databases
25
Getting ready
25
How to do it…
25
Table of Contents
Table of Contents
viii
Establishing a database connection
27
See also
28
Understanding CRUD 
operations with SQLAlchemy
28
Getting ready
29
How to do it…
29
See also
32
Integrating MongoDB 
for NoSQL data storage
32
Getting ready
32
How to do it…
33
See also
35
Working with data validation 
and serialization
36
Getting ready
36
How to do it…
36
Serialization and deserialization concepts
37
Advanced validation techniques
38
See also
39
Working with file uploads 
and downloads
39
Getting ready
39
How to do it…
39
Implementing file uploads
40
Managing file downloads and storage
41
See also
42
Handling asynchronous 
data operations
42
Getting ready
42
How to do it…
42
There’s more…
46
See also
46
Securing sensitive data 
and best practices
47
Getting ready
47
How to do it…
48
There’s more…
48
3
Building RESTful APIs with FastAPI
51
Technical requirements
52
Creating CRUD operations
52
How to do it…
53
How it works...
56
Creating RESTful Endpoints
57
Get
Table of Contents 
ix
See also
73
Documenting your API 
with Swagger and Redoc
74
Getting ready…
74
How to do it...
74
See also
75
4
Authentication and Authorization
77
Technical requirements
78
Setting up user registration
78
Getting ready
78
How to do it…
79
How it works...
82
See also
83
Working with OAuth2 
and JWT for authentication
83
Getting ready
83
How to do it...
83
How it works…
87
See also
88
Setting up RBAC
88
Getting ready
88
How to do it...
90
There’s more…
93
Using third-party authentication
94
Getting ready
94
How to do it...
95
How it works…
98
See also
99
Implementing MFA
99
Getting ready
100
How to do it...
100
See also
103
Handling API key authentication
103
Getting ready
104
How to do it...
104
There’s more…
105
Handling session cookies 
and logout functionality
105
Getting ready
106
How to do it...
106
There’s more…
107
See also
108
5
Testing and Debugging FastAPI Applications
109
Technical requirements
110
Setting up test
Table of Contents
x
Getting ready
114
How to do it…
118
See also
120
Running tests techniques
120
Getting ready
120
How to do it...
120
Check test coverage
122
See also
122
Handling logging messages
123
Getting ready
123
How to do it...
123
There’s more
125
See also
126
Debugging techniques
126
Getting ready
126
How to do it...
126
Debugging with PDB
127
Debugging with VS Code
128
Debugging with PyCharm
129
See also
130
Performance testing 
for high traffic applications
131
Getting ready
131
How to do it...
131
See also
133
6
Integrating FastAPI with SQL Databases
135
Technical requirements
136
Setting up SQLAlchemy
136
Getting ready
136
How to do it...
137
How it works…
139
See also
140
Implementing CRUD operations
141
Getting ready
141
How to do it…
141
How it works…
144
Working with migrations
144
Getting ready
145
How to do it…
145
How it works…
146
See also
147
Handling relationships 
in SQL databases
147
Getting ready
147
How to do it…
1
Table of Contents 
xi
7
Integrating FastAPI with NoSQL Databases
167
Technical requirements
168
Setting up MongoDB with FastAPI
168
Getting ready
168
How to do it…
169
See also
171
CRUD operations in MongoDB
171
Getting ready
171
How to do it…
171
See also
175
Handling relationships 
in NoSQL databases
175
Getting ready
176
How to do it…
176
See also
179
Working with indexes 
in MongoDB
179
Getting ready
179
How to do it…
179
How it works…
180
There’s more…
181
See also
183
Exposing sensitive data 
from NoSQL databases
183
Getting ready
183
How to do it…
184
There’s more…
188
See also
189
Integrating FastAPI 
with Elasticsearch
189
Getting ready
189
How to do it…
190
See also
196
Using Redis for caching 
in FastAPI
197
Getting ready
197
How to do it…
198
There’s more…
200
See also
200
8
Advanced Features and Best Practices
201
Technical requirements
202
Implementing dependency 
injection
202
Getting ready
202
How to do it…
203
How it works…
206
T
Table of Contents
xii
See also
216
Optimizing application 
performance
216
Getting ready
216
How to do it…
217
There’s more...
218
See also
219
Implementing rate limiting
219
Getting ready
220
How to do it…
220
There's more...
221
See also
222
Implementing background tasks
222
Getting ready
223
How to do it…
223
How it works…
224
See also
224
9
Working with WebSocket
225
Technical requirements
225
Setting up WebSockets in FastAPI
226
Getting ready
226
How to do it…
227
How it works…
227
See also
228
Sending and receiving 
messages over WebSockets
228
Getting ready
228
How to do it…
228
See also
230
Handling WebSocket connections 
and disconnections
230
Getting ready
230
How to do it…
230
Handling WebSocket errors 
and exceptions
232
Getting ready
232
How to do it…
232
See also
234
Implementing chat functionality 
with WebSockets
235
Getting ready
235
How to do it…
236
How it works…
239
See also
240
Optimizing WebSocket 
performance
240
Getting re
Table of Contents 
xiii
10
Integrating FastAPI with other Python Libraries
249
Technical requirements
250
Integrating FastAPI with gRPC
250
Getting ready
250
How to do it…
253
There’s more…
254
See also
255
Connecting FastAPI with GraphQL
255
Getting ready
255
How to do it…
256
See also
258
Using ML models with Joblib
259
Getting ready
259
How to do it…
260
See also
262
Integrating FastAPI with Cohere
262
Getting ready
263
How to do it…
264
See also
267
Integrating FastAPI 
with LangChain
267
Getting ready
267
How to do it…
268
See also
275
11
Middleware and Webhooks
277
Technical requirements
278
Creating custom ASGI middleware
278
Getting ready
278
How to do it…
279
How it works…
280
There’s more…
281
See also
282
Developing middleware 
for request modification
282
Getting ready
283
How to do it…
283
See also
286
Developing middleware 
for response modification
286
Getting ready
286
How to do it…
286
See also
289
Handling CORS with middleware
2
Table of Contents
xiv
12
Deploying and Managing FastAPI Applications
301
Technical requirements
302
Running the server with 
the FastAPI CLI
302
Getting ready
302
How to do it…
303
There’s more…
304
See also
305
Enabling HTTPS on FastAPI 
applications
305
Getting ready
305
How to do it…
306
There’s more…
307
See also
308
Running FastAPI applications 
in Docker containers
308
Getting ready
308
How to do it…
309
See also
311
Running the server 
across multiple workers
311
Getting ready
311
How to do it…
311
There’s more…
313
See also
313
Deploying your FastAPI 
application on the cloud
314
Getting started
314
How to do it…
314
There’s more…
316
See also
316
Shipping FastAPI applications 
with Hatch
317
Getting ready
317
How to do it…
318
There’s more…
321
See also
322
Index
323
Other Books You May Enjoy
332
Preface
FastAPI Cookbook is a vital resource for Python developers who want to master the FastAPI framework 
to build APIs. Created by Sebastián Ramírez Montaño, FastAPI was first released in December 2018. It 
quickly gained popularity and became one of the most widely used Python frameworks for building APIs.
The book starts by introducing FastAPI, showing its advantages, and it will help you set up your 
development environment. It then moves on to data handling, showing database integration and create, 
read, update and delete (CRUD) operations, to help you manage data effectively within your APIs.
As the book progresses, it explores how to create RESTful APIs, covering advanced topics such as 
complex queries, versioning, and extensive documentation. Security is also important, and the book 
has a chapter on implementing authentication mechanisms such as OAuth2 and JWT tokens to secure 
FastAPI applications.
Testing is an essential part of development, and the book offers strategi
Preface
xvi
What this book covers
Chapter 1, First Steps with FastAPI, serves as an introduction to the framework, emphasizing its speed, 
ease of use, and comprehensive documentation. This chapter is the gateway for you to set up your 
development environment, create your first FastAPI project, and explore its fundamental concepts.
Chapter 2, Working with Data, is dedicated to mastering the critical aspect of data handling in web 
applications. It covers the intricacies of integrating, managing, and optimizing data storage using 
both SQL and NoSQL databases.
Chapter 3, Building RESTful APIs with FastAPI, dives into the essentials of constructing RESTful 
APIs, which are fundamental to web services, enabling applications to communicate and exchange 
data efficiently.
Chapter 4, Authentication and Authorization, delves into the critical realms of securing your web 
applications against unauthorized access. It covers the basics of user registration and authentication, 
the integration o
Preface
xvii
Chapter 11, Middleware and Webhooks, delves into the advanced and crucial aspects of middleware 
and Webhooks in FastAPI. Middleware allows you to process requests and responses globally, while 
Webhooks enable your FastAPI application to communicate with other services by sending real-time 
data updates.
Chapter 12, Deploying and Managing FastAPI Applications, covers the knowledge and tools needed 
to deploy FastAPI applications seamlessly, leveraging various technologies and best practices. You 
will learn how to utilize the FastAPI CLI to run your server efficiently, enable HTTPS to secure your 
applications, and containerize your FastAPI projects with Docker.
To get the most out of this book
You should have a fundamental understanding of Python programming, as the book assumes 
familiarity with Python syntax and concepts. Additionally, knowledge of web development principles, 
including HTTP, RESTful APIs, and JSON, will be beneficial. Familiarity with SQL and NoSQL da
Preface
xviii
A block of code is set as follows:
from locust import HttpUser, task
class ProtoappUser(HttpUser):
    host = "http://localhost:8000"
    @task
    def hello_world(self):
        self.client.get("/home")
When we wish to draw your attention to a particular part of a code block, the relevant lines or items 
are set in bold:
from pydantic import BaseModel, Field
class Book(BaseModel):
    title: str = Field(..., min_length=1, max_length=100)
    author: str = Field(..., min_length=1, max_length=50)
    year: int = Field(..., gt=1900, lt=2100)
Any command-line input or output is written as follows:
$ pytest –-cov protoapp tests
Throughout this book, we will generally use Unix-like terminal commands. This might lead to 
compatibility issues with Windows for commands that run on multiple lines. If you are using a 
Windows terminal, consider adapting the newline character \ as follows:
$ python -m grpc_tools.protoc \ 
--proto_path=. ./grpcserver.proto \ 
--python_out=. \ 
--grpc
Preface
xix
Here is the line in Powershell:
$ python -m grpc_tools.protoc `
--proto_path=. ./grpcserver.proto `
--python_out=. `
--grpc_python_out=.
Bold: Indicates a new term, an important word, or words that you see onscreen. For example, words 
in menus or dialog boxes appear in the text like this. Here is an example: “This limit can be adjusted 
in the settings (Settings | Advanced Settings | Run/Debug | Temporary configurations limit).”
Tips or important notes
Appear like this.
Sections
In this book, you will find several headings that appear frequently (Getting ready, How to do it..., How 
it works..., There’s more..., and See also).
To give clear instructions on how to complete a recipe, use these sections as follows.
Getting ready
This section tells you what to expect in the recipe and describes how to set up any software or 
preliminary settings required for it.
How to do it…
This section contains the steps required to follow the recipe.
How it works…
This section usually cons
Preface
xx
Get in touch
Feedback from our readers is always welcome.
General feedback: If you have questions about any aspect of this book, mention the book title in the 
subject of your message and email us at customercare@packtpub.com.
Errata: Although we have taken every care to ensure the accuracy of our content, mistakes do happen. 
If you have found a mistake in this book, we would be grateful if you would report this to us. Please 
visit www.packtpub.com/support/errata, select your book, click on the Errata Submission 
Form link, and enter the details.
Piracy: If you come across any illegal copies of our works in any form on the internet, we would 
be grateful if you would provide us with the location address or website name. Please contact us at 
copyright@packt.com with a link to the material.
If you are interested in becoming an author: If there is a topic that you have expertise in and you 
are interested in either writing or contributing to a book, please visit authors.pack
Preface
xxi
Download a free PDF copy of this book
Thanks for purchasing this book!
Do you like to read on the go but are unable to carry your print books everywhere?
Is your eBook purchase not compatible with the device of your choice?
Don’t worry, now with every Packt book you get a DRM-free PDF version of that book at no cost.
Read anywhere, any place, on any device. Search, copy, and paste code from your favorite technical 
books directly into your application. 
The perks don’t stop there, you can get exclusive access to discounts, newsletters, and great free content 
in your inbox daily
Follow these simple steps to get the benefits:
1.	
Scan the QR code or visit the link below
 
https://packt.link/free-ebook/978-1-80512-785-7
2.	
Submit your proof of purchase
3.	
That’s it! We’ll send your free PDF and other benefits to your email directly

1
First Steps with FastAPI
Welcome to the exciting world of FastAPI, a modern, high-performance framework for building APIs 
and web applications in Python. This first chapter is your gateway to understanding and harnessing the 
power of FastAPI. Here, you’ll take your initial steps into setting up your development environment, 
creating your very first FastAPI project, and exploring its fundamental concepts.
FastAPI stands out for its speed, ease of use, and comprehensive documentation, making it a preferred 
choice for developers looking to build scalable and efficient web applications. In this chapter, you’ll 
practically engage in setting up FastAPI, learning how to navigate its architecture, and understanding 
its core components. You’ll gain hands-on experience by defining simple API endpoints, handling 
HTTP methods, and learning about request and response handling. These foundational skills are 
crucial for any developer stepping into the world of modern web development with Fa
First Steps with FastAPI
2
Technical requirements
To embark on your journey with FastAPI, you’ll need to set up an environment that supports Python 
development and FastAPI’s functionalities. Here’s a list of the technical requirements and installations 
needed for this chapter:
•	 Python: FastAPI is built on Python, so you’ll need a Python version compatible with your 
FastAPI version. You can download the latest version of it from python.org.
•	 FastAPI: Install FastAPI using pip, Python’s package manager. You can do it by running pip 
install fastapi from the command terminal.
•	 Uvicorn: FastAPI requires an Asynchronous Server Gateway Interface (ASGI) server, and 
Uvicorn is a lightning-fast ASGI server implementation. Install it using pip install 
uvicorn.
•	 Integrated development environment (IDE): An IDE such as Visual Studio Code (VS Code), 
PyCharm, or any other IDE that supports Python development will be necessary for writing 
and testing your code.
•	 Postman or Swagger UI
Setting up your development environment
3
Lastly, we’ll introduce you to Git and GitHub – indispensable tools for version control and collaboration 
in modern software development. Understanding how to use these tools will not only help you 
manage your code effectively but also open doors to the vast world of community-driven development 
and resources.
Getting ready
FastAPI works with Python, so you need to check your Python version before using it. This is an 
important step for setting up FastAPI. We will guide you through how to install it.
Windows installation
If you work on Windows, follow these steps to install Python:
1.	
Visit the official Python website: python.org.
2.	
Download the latest version of Python or any other version higher than 3.9.
3.	
Run the installer. Ensure to check the box that says Add Python to PATH before clicking 
Install Now.
4.	
After the installation, open Command Prompt and type python --version to confirm 
the installation.
macOS/Linux installation
First Steps with FastAPI
4
If you installed it on Linux, the binary command is python3, so you can check that Python is correctly 
installed by running the following command:
$ python3 --version
Once Python is installed, we want to make sure that the Python’s package manager is correctly installed. 
It comes with Python’s installation, and it’s called pip.
From a terminal window, run the following command:
$ pip --version
On Linux, run the following command:
$ pip3 --version
Once Python is installed on your computer, you can now consider installing FastAPI.
How to do it...
When you have Python and pip ready, we can continue with installing FastAPI, the IDE. Then, we 
will configure Git.
We will do it by following these steps:
1.	
Installing FastAPI and Uvicorn
2.	
Setting up your IDE (VS Code or PyCharm)
3.	
Setting up Git and GitHub to track your project
Installing FastAPI and Uvicorn
With Python set up, the next step is installing FastAPI and Uvicorn. FastAPI is the framework we’ll u
Setting up your development environment
5
A good IDE can significantly enhance your coding experience and productivity. For FastAPI development 
and Python in general, two popular choices are VS Code and PyCharm.
VS Code
VS Code is a free, open source, lightweight IDE with powerful features. It offers excellent Python 
support and is highly customizable.
You can download and install VS Code from the official website (code.visualstudio.com). 
The installation is quite straightforward. Once installed, open VS Code, go to Extensions (a square 
icon on the left bar), and search for python. Install the Microsoft version, and that is it.
PyCharm
PyCharm, created by JetBrains, is specifically tailored for Python development. It offers a broad range 
of tools for professional developers, including excellent support for web development frameworks 
such as FastAPI.
You can choose between a Community free edition and a Professional paid version. For the scope 
of the book, the Community Edition i
First Steps with FastAPI
6
After installation, configure Git with your username and email using the following commands in the 
command line:
$ git config --global user.name "Your Name"
$ git config --global user.email "your.email@example.com"
GitHub is the platform chosen to store code examples used in the book. Sign up for a GitHub account 
at github.com if you don’t already have one.
Creating a new FastAPI project
Setting up a well-organized project structure is crucial for maintaining a clean code base, especially 
as your application grows and evolves. This recipe will guide you on how to create your first basic 
FastAPI project. A structured project simplifies navigation, debugging, and collaboration. For FastAPI, 
following best practices in structuring can significantly enhance scalability and maintainability.
Getting ready
All you need to do to follow the recipe is make sure that you have your development environment set up.
How to do it...
We begin by making a project folder n
Creating a new FastAPI project
7
3.	
Now, you can install the fastapi package with uvicorn in your environment by running 
the following command:
$ pip install fastapi uvicorn
Once FastAPI is installed in your environment, open your project folder with your favorite 
IDE and create a file called main.py.
4.	
This file is where your FastAPI application begins. Start by writing the import of the FastAPI 
module. Then, create an instance of the FastAPI class:
from fastapi import FastAPI
app = FastAPI()
This instance houses the code of your application.
5.	
Next, define your first route. Routes in FastAPI are like signposts that direct requests to the 
appropriate function. Start with a simple route that returns a greeting to the world:
@app.get("/")
def read_root():
    return {"Hello": "World"}
You’ve just created the code for your first FastAPI application.
If you want to track the project, you can set up Git as follows:
1.	
In your project’s root directory, open a terminal or Command P
First Steps with FastAPI
8
There’s more...
A well-structured project is not just about neatness; it’s about creating a sustainable and scalable 
environment where your application can grow and evolve. In FastAPI, this means organizing your 
project in a way that separates different aspects of your application logically and efficiently.
There is no unique and perfect structure for a FastAPI project; however, a common approach is to 
divide your project into several key directories:
•	 /src: This is where your primary application code lives. Inside /src, you might have 
subdirectories for different modules of your application. For instance, you could have a 
models directory for your database models, a routes directory for your FastAPI routes, 
and a services directory for business logic.
•	 /tests: Keeping your tests separate from your application code is a good practice. It makes 
it easier to manage them and ensures that your production builds don’t include test code.
•	 /docs: Docume
Understanding FastAPI basics
9
Key features that define FastAPI are the following:
•	 Speed: It’s one of the fastest frameworks for building APIs in Python, thanks to its underlying 
Starlette framework for web parts and Pydantic for data handling
•	 Ease of use: FastAPI is designed to be easy to use, with intuitive coding that accelerates your 
development time
•	 Automatic documentation: With FastAPI, the API documentation is generated automatically, 
a feature that is both a time-saver and a boon for developers
How to do it…
We will now explore how to use those features effectively with some general guidance.
We will go through the following steps:
•	 Applying asynchronous programming to our existing endpoints to improve time efficiency
•	 Exploring routers and endpoints to better organize large code bases
•	 Running your first FastAPI server with a basic configuration
•	 Exploring the automatic documentation
Applying asynchronous programming
One of the most powerful features of Fas
First Steps with FastAPI
10
Endpoints
Endpoints are the points at which API interactions happen. In FastAPI, an endpoint is created by 
decorating a function with an HTTP method, such as @app.get("/").
This signifies a GET request to the root of your application.
Consider the following code snippet:
from fastapi import FastAPI
app = FastAPI()
@app.get("/")
async def read_root():
    return {"Hello": "World"}
In this snippet, we define an endpoint for the root URL ("/"). When a GET request is made to this 
URL, the read_root function is invoked, returning a JSON response.
Routers
When we need to handle multiple endpoints that are in different files, we can benefit from using 
routers. Routers assist us in grouping our endpoints into different modules, which makes our code 
base easier to maintain and understand. For example, we could use one router for operations related 
to users and another for operations related to products.
To define a router, first create a new file in the fastapi_
Understanding FastAPI basics
11
app.include_router(router_example.router)
@app.get("/")
async def read_root():
    return {"Hello": "World"}
You now have the code to run the server that includes the router for the GET /items endpoint 
importer from another module.
Running your first FastAPI server
To run your FastAPI application, you need to point Uvicorn to your app instance. If your file is 
named main.py and your FastAPI instance is called app, you can start your server like this at the 
fastapi_start folder level:
$ uvicorn main:app --reload
The --reload flag makes the server restart after code changes, making it ideal for development.
Once the server is running, you can access your API at http://127.0.0.1:8000. If you visit 
this URL in your browser, you’ll see the JSON response from the "/" endpoint we have just created.
Exploring the automatic documentation
One of the most exciting features of FastAPI is its automatic documentation. When you run your 
FastAPI application, two do
First Steps with FastAPI
12
Defining your first API endpoint
Now that you have a fundamental grasp of FastAPI and your development environment is all set up, 
it’s time to take the next thrilling step: creating your first API endpoint.
This is where the real magic of FastAPI begins to shine. You’ll see how effortlessly you can build a 
functional API endpoint, ready to respond to HTTP requests.
In this recipe, you will create a basic draft of a backend service for a bookstore.
Getting ready
Make sure you know how to start a basic FastAPI project from the Creating a new FastAPI project recipe.
How to do it...
In the realm of web APIs, the GET request is perhaps the most common. It’s used to retrieve data from 
the server. In FastAPI, handling a GET request is simple and intuitive. Let’s create a basic GET endpoint.
Imagine you’re building an API for a bookstore. Your first endpoint will provide information about 
a book when given its ID. Here’s how you do it:
1.	
Create a new bookstore
Working with path and query parameters
13
Type hints and automatic data validation
Notice the use of type hints (book_id: int). FastAPI uses these hints to perform data 
validation. If a request is made with a non-integer book_id parameter, FastAPI automatically 
sends a helpful error response.
How it works…
With your GET endpoint defined, run your FastAPI application using Uvicorn, just as you did previously:
$ uvicorn main:app --reload
On the terminal, you can read the message logs describing that the server is running on port 8000.
One of FastAPI’s most beloved features is its automatic generation of interactive API documentation 
using Swagger UI. This tool allows you to test your API endpoints directly from your browser without 
writing any additional code, and you can directly check the presence of the newly created endpoint in it.
Using Swagger UI
To test your new GET endpoint, navigate to http://127.0.0.1:8000/docs in your browser. 
This URL brings up the Swagger UI documentati
First Steps with FastAPI
14
Getting ready
To follow the recipe, make sure you know how to create a basic endpoint from the previous recipe.
How to do it…
Path parameters are parts of the URL that are expected to change. For instance, in an endpoint such 
as /books/{book_id}, book_id is a path parameter. FastAPI allows you to capture these 
parameters effortlessly and use them in your function.
1.	
Let’s expand our bookstore API with a new endpoint that uses path parameters. This time, we’ll 
create a route to get information about a specific author:
@app.get("/authors/{author_id}")
async def read_author(author_id: int):
    return {
        "author_id": author_id,
        "name": "Ernest Hemingway"
    }
The name will not change; however, the author_id value will be the one provided by the 
query request.
Query parameters are used to refine or customize the response of an API endpoint. 
They can be included in the URL after a question mark (? ). For instance, /
books?genre=fiction&year
Defining and using request and response models
15
Exercise
Using the APIRouter class, refactor each endpoint in a separate file and add the route to 
the FastAPI server.
How it works…
Now, from the command terminal, spin up the server with Uvicorn by running the following command:
$ uvicorn main:app
Testing endpoints with path parameters can be done using Swagger UI or Postman, similar to how 
we tested our basic GET endpoint.
In Swagger UI, at http://localhost:8000/docs, navigate to your /authors/{author_id} 
endpoint. You’ll notice that it prompts you to enter an author_id value before you can try it out. 
Enter a valid integer and execute the request. You should see a response with the author’s information.
The GET /books endpoint will now show an optional field for the year query parameter. You can 
test it by entering different years and observing the varying responses.
If you use Postman instead, create a new GET request with the http://127.0.0.1:8000/
authors/1 URL. Sending this
First Steps with FastAPI
16
Pydantic models are a powerful feature for data validation and conversion. They allow you to define 
the structure, type, and constraints of the data your application handles, both for incoming requests 
and outgoing responses.
In this recipe, we will see how to use Pydantic to ensure that your data conforms to the specified 
schema, providing an automatic layer of safety and clarity.
Getting ready
This recipe requires you to know how to set up a basic endpoint in FastAPI.
How to do it...
We will break the process into the following steps:
1.	
Creating the model
2.	
Defining the request body
3.	
Validating request data
4.	
Managing response formats
Creating the model
Let’s create a Pydantic BaseModel class for our bookstore application in a new file called models.py.
Suppose we want to have a model for a book that includes the title, author, and publication year:
from pydantic import BaseModel
class Book(BaseModel):
    title: str
    author: str
    year: i
Defining and using request and response models
17
async def create_book(book: Book):
    return book
In this endpoint, when a user sends a POST request to the /book endpoint with JSON data, FastAPI 
automatically parses and validates it against the Book model. If the data is invalid, the user gets an 
automatic error response.
Validating request data
Pydantic offers advanced validation features. For instance, you can add regex validations, default 
values, and more:
from pydantic import BaseModel, Field
class Book(BaseModel):
    title: str = Field(..., min_length=1, max_length=100)
    author: str = Field(..., min_length=1, max_length=50)
    year: int = Field(..., gt=1900, lt=2100)
For an exhaustive list of validation features, have a look at Pydantic’s official documentation: 
https://docs.pydantic.dev/latest/concepts/fields/.
Next, you can proceed to manage the response format.
Managing response formats
FastAPI allows you to define response models explicitly, ensuring that the data
First Steps with FastAPI
18
            "title": "1984",
            "author": "George Orwell"},
        {
            "id": 1,
            "title": "The Great Gatsby",
            "author": "F. Scott Fitzgerald",
        },
    ]
Here, the -> list[BookResponse] function type hint tells FastAPI to use the BookResponse 
model for responses, ensuring that only the title and author fields are included in the response JSON. 
Alternatively, you can specify the response type in the endpoint decorator’s arguments as follows:
@app.get("/allbooks", response_model= list[BookResponse])
async def read_all_books() -> Any:
# rest of the endpoint content
The response_model argument takes priority and can be used instead of the type hint to resolve 
type checker issues that may occur.
Check the documentation at http://127.0.0.1:8000/docs. Unroll the /allbooks endpoint 
details, and you will notice the example value response based on the schema as follows:
[
  {
    "title": "string",
    "author": "st
Handling errors and exceptions
19
You can see more on response model usage at the FastAPI official documentation link:
•	 Response Model - Return Type: https://fastapi.tiangolo.com/tutorial/
response-model/
Handling errors and exceptions
Error handling is an essential aspect of developing robust and reliable web applications. In FastAPI, 
managing errors and exceptions is not just about catching unexpected issues but also about proactively 
designing your application to respond to various error scenarios gracefully.
This recipe will guide you through custom error handling, validating data and handling exceptions, 
and testing these scenarios to ensure your FastAPI applications are resilient and user-friendly.
How to do it…
FastAPI provides built-in support for handling exceptions and errors.
When an error occurs, FastAPI returns a JSON response containing details about the error, which is 
very useful for debugging. However, there are situations where you might want to customize these 
First Steps with FastAPI
20
You can test the response by creating a new endpoint that raises an HTTP exception:
@app.get("/error_endpoint")
async def raise_exception():
    raise HTTPException(status_code=400)
The endpoint will explicitly throw the HTTP error response to showcase the customized message 
defined in the previous step.
Now, spin the server from the command line with the following command:
$ uvicorn main:app
Open the browser at http://localhost:8000/error_endpoint, and you will have a JSON 
response like this:
{
    "message": "Oops! Something went wrong"
}
The response returns the default message we defined for any HTTP exception returned by the code.
There’s more…
As discussed in the previous recipe, Defining and using request and response models, FastAPI uses 
Pydantic models for data validation. When a request is made with data that does not conform to the 
defined model, FastAPI automatically raises an exception and returns an error response.
In some cases, you might 
Handling errors and exceptions
21
        status_code=status.HTTP_400_BAD_REQUEST,
    )
This custom handler will catch any RequestValidationError error and return a plain text 
response with the details of the error.
If you try, for example, to call the POST /book endpoint with a number type of title instead of 
a string, you will get a response with a status code of 400 and body:
This is a plain text response:
[
  {
    "type": "string_type",
    "loc": [
      "body",
      "author"
    ],
    "msg": "Input should be a valid string",
    "input": 3,
    "url": "https://errors.pydantic.dev/2.5/v/string_type"
  },
  {
    "type": "greater_than",
    "loc": [
      "body",
      "year"
    ],
    "msg": "Input should be greater than 1900",
    "input": 0,
    "ctx": {
      "gt": 1900
    },
    "url": "https://errors.pydantic.dev/2.5/v/greater_than"
  }
]
You can also, for example, mask the message to add a layer of security to protect from unwanted users 
using it incorrectly.
This i
First Steps with FastAPI
22
You will use this basic knowledge as you move to the next chapter. Chapter 2 will teach you more 
about data management in web applications, showing you how to set up and use SQL and NoSQL 
databases and stressing data security. This will not only improve your technical skills but also increase 
your awareness of creating scalable and reliable FastAPI applications.
See also
You can find more information about customizing errors and exceptions using FastAPI in the 
official documentation:
•	 Handling Errors: https://fastapi.tiangolo.com/tutorial/handling-errors/
2
Working with Data
Data handling is the backbone of any web application, and this chapter is dedicated to mastering 
this critical aspect. You will embark on a journey of working with data in FastAPI, where you’ll learn 
the intricacies of integrating, managing, and optimizing data storage using both Structured Query 
Language (SQL) and NoSQL databases. We’ll cover how FastAPI, combined with powerful database 
tools, can create efficient and scalable data management solutions.
Starting with SQL databases, you’ll get hands-on experience in setting up a database, implementing 
create, read, update and delete (CRUD) operations, and understanding the nuances of working with 
SQLAlchemy – a popular object-relational mapping (ORM) option for Python. We’ll then shift gears 
to NoSQL databases, delving into the world of MongoDB. You’ll learn how to integrate it with FastAPI, 
handle dynamic data structures, and leverage the flexibility and scalability of NoSQL solutions.
But it’s not just abo
Working with Data
24
•	 Handling asynchronous data operations
•	 Securing sensitive data and best practices
Each topic is designed to equip you with the necessary skills and knowledge to handle data in FastAPI 
efficiently, ensuring your applications are not only functional but also secure and scalable.
Technical requirements
To effectively run and understand the code in this chapter, ensure you have the following set up. If 
you’ve followed Chapter 1, First Steps with FastAPI, you should already have some of these installed:
•	 Python: Make sure you’ve installed Python version 3.9 or higher on your computer.
•	 FastAPI: Install FastAPI along with all its dependencies using the pip install 
fastapi[all] command. As we saw in Chapter 1, First Steps with FastAPI, this command 
also installs Uvicorn, an ASGI server that’s necessary to run your FastAPI application.
•	 Integrated development environment (IDE): A suitable IDE such as VS Code or PyCharm 
should be installed. These IDEs offer 
Setting up SQL databases
25
Setting up SQL databases
In the world of data handling, the power of Python meets the efficiency of SQL databases. This recipe 
aims to introduce you to how to integrate SQL databases within your application, a crucial skill for 
any developer looking to build robust and scalable web applications.
SQL is the standard language for managing and manipulating relational databases. When combined 
with FastAPI, it unlocks a world of possibilities in data storage and retrieval.
FastAPI’s compatibility with SQL databases is facilitated through ORMs. The most popular one is 
SQLAlchemy. We will focus on it in this recipe.
Getting ready
To begin, you’ll need to have FastAPI and SQLAlchemy installed in your virtual environment. If you 
followed the steps in Chapter 1, First Steps with FastAPI, you should have FastAPI already set up. For 
SQLAlchemy, a simple pip command is all that’s needed:
$ pip install sqlalchemy
Once installed, the next step is to configure SQLAlch
Working with Data
26
To define a model in SQLAlchemy, you need to create a base class that derives from the 
DeclarativeBase class. This Base class maintains a catalog of classes and tables you’ve 
defined and is central to SQLAlchemy’s ORM functionality.
You can learn more by reading the official documentation: https://docs.sqlalchemy.
org/en/13/orm/extensions/declarative/index.html.
2.	
Once you have your Base class, you can start defining your models. For instance, if you have 
a table for users, your model might look something like this:
from sqlalchemy.orm import (
    Mapped,
    mapped_column
)
class User(Base):
    __tablename__ = "user"
    id: Mapped[int] = mapped_column(
        primary_key=True,
    )
    name: Mapped[str]
    email: Mapped[str]
In this model, User class corresponds to a table named user in the database, with columns 
for id, name, and email. Each class attribute specifies the data type of the column.
3.	
Once your models have been defined, the next step is
Setting up SQL databases
27
5.	
With the engine created, you can proceed to create your tables in the database. You can do this 
by passing your base class and the engine to SQLAlchemy’s create_all method:
Base.metadata.create_all(bind=engine)
Now that you’ve defined all the abstractions of the database in your code, you can proceed with setting 
the database connection.
Establishing a database connection
The final part of setting up a SQL database setup is establishing a database connection. This connection 
allows your application to communicate with the database, executing queries and retrieving data.
Database connections are managed with sessions. A session in SQLAlchemy represents a workspace 
for your objects, a place where you can add new records or fetch existing ones. Each session is bound 
to a single database connection.
To manage sessions, we need to create a SessionLocal class. This class will be used to create and 
manage session objects for the interactions with the data
Working with Data
28
In your route functions, you can use this function as a dependency to communicate with 
the database.
In FastAPI, this can be done with the Depends class. In the main.py file, you can then add an endpoint:
from fastapi import Depends, FastAPI
from sqlalchemy.orm import Session
from database import SessionLocal
app = FastAPI()
@app.get("/users/")
def read_users(db: Session = Depends(get_db)):
    users = db.query(User).all()
    return users
This approach ensures that a new session is created for each request and closed when the request is 
finished, which is crucial for maintaining the integrity of your database transactions.
You can then run the server with the following command:
$ uvicorn main:app –-reload
If you try to call the endpoint GET at localhost:8000/users you will get an empty list since 
no users have been added already.
See also
You can discover more on how to set up a session in SQLAlchemy on the documentation page:
•	 SQLAlchemy session: https://doc
Understanding CRUD operations with SQLAlchemy
29
Getting ready
With the models set up, you can now implement CRUD operations. These operations form the 
backbone of most web applications, allowing you to interact with the database.
How to do it…
For each operation, we will create a dedicated endpoint implementing the interacting operation with 
the database.
Creating a new user
To add a new user, we’ll use a POST request. In the main.py file, we must define an endpoint that 
receives user data, creates a new User instance in the body request, and adds it to the database:
class UserBody(BaseModel):
    name: str
    email: str
@app.post("/user")
def add_new_user(
    user: UserBody,
    db: Session = Depends(get_db)
):
    new_user = User(
        name=user.name,
        email=user.email
    )
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return new_user
In a few lines, you’ve created the endpoint to add a new user to the database.
Reading a specific user
To get a si
Working with Data
30
    user_id: int,
    db: Session = Depends(get_db)
    ):
    user = (
        db.query(User).filter(
            User.id == user_id
        ).first()
    )
    if user is None:
        raise HTTPException(
            status_code=404,
            detail="User not found"
        )
    return user
The endpoint will return a 404 response status if the user does not exist.
Updating a user
Updating a record via an API offers various approaches, including PUT, PATCH, or POST methods. 
Despite theoretical nuances, the choice of method often boils down to personal preference. I favor using 
a POST request and augmenting the /user endpoint with a user_id parameter. This simplifies 
the process, minimizing the need for extensive memorization. You can integrate this endpoint within 
the main.py module like so:
@app.post("/user/{user_id}")
def update_user(
    user_id: int,
    user: UserBody,
    db: Session = Depends(get_db),
):
    db_user = (
        db.query(User).filte
Understanding CRUD operations with SQLAlchemy
31
    db_user.name = user.name
    db_user.email = user.email
    db.commit()
    db.refresh(db_user)
    return db_user
This is all you need to do to create the endpoint to update a user record in the database.
Deleting a user
To conclude, deleting a user within the same main.py module involves utilizing a DELETE request, 
as shown here:
@app.delete("/user")
def delete_user(
    user_id: int, db: Session = Depends(get_db)
):
    db_user = (
        db.query(User).filter(
            User.id == user_id
        ).first()
    )
    if db_user is None:
        raise HTTPException(
            status_code=404,
            detail="User not found"
        )
    db.delete(db_user)
    db.commit()
    return {"detail": "User deleted"}
These endpoints cover the basic CRUD operations and demonstrate how FastAPI can be integrated 
with SQLAlchemy for database operations. By defining these endpoints, your application can create, 
retrieve, update, and
Working with Data
32
Mastering these CRUD operations in FastAPI is a significant step in building dynamic and data-driven 
web applications. With the knowledge of how to integrate FastAPI endpoints with SQLAlchemy 
models, you are well-equipped to develop complex and efficient applications.
See also
You can find a clear quick start on how to set up the ORM for CRUD operations with SQLAlchemy 
on the official documentation page:
•	 SQLAlchemy ORM Quick Start: https://docs.sqlalchemy.org/en/20/orm/
quickstart.html
Integrating MongoDB for NoSQL data storage
Transitioning from SQL to NoSQL databases opens up a different paradigm in data storage and 
management. NoSQL databases, like MongoDB, are known for their flexibility, scalability, and ability 
to handle large volumes of unstructured data. In this recipe, we’ll explore how to integrate MongoDB, 
a popular NoSQL database, with FastAPI.
NoSQL databases differ from traditional SQL databases in that they often allow for more dynamic and 

Integrating MongoDB for NoSQL data storage
33
How to do it…
We can quickly connect our application to a Mongo DB instance running on our local machine by 
by applying the following steps.
1.	
Create a new project folder called nosql_example. Start by defining connection configuration 
in a database.py file:
From pymongo import MongoClient
client = MongoClient()
database = client.mydatabase
In this example, mydatabase is the name of your database. You can replace it with the name 
you prefer. Here, MongoClient establishes a connection to a MongoDB instance running 
locally on the default port of 27017.
2.	
Once the connection has been set up, you can define your collections (equivalent to tables 
in SQL databases) and start interacting with them. MongoDB stores data in collections of 
documents, where each document is a JSON-like structure:
user_collection = database["users"]
Here, user_collection is a reference to the users collection in your MongoDB database.
3.	
To test the connectio
Working with Data
34
4.	
Now, run your mongod instance. You can do it from the command line:
$ mongod
If you run on Windows the command will be:
$ C:\Program>Files\MongoDB\Server\7.0\bin\mongod
And that's it. To test it, in a separate terminal window, spin up the FastAPI server by running the 
following command:
$ uvicorn main:app
Then, simply open your browser at http://localhost:8000/users; you will get an empty 
list. This means that your database connection is correctly working.
Now that the connection has been set up, we are going to create an endpoint to add a user and one to 
retrieve a specific user with an ID. We’ll create both endpoints in the main.py module.
Creating a new user
To add a new document to a collection, use the insert_one method:
class UserResponse(User):
    id: str
@app.post("/user")
def create_user(user: User):
    result = user_collection.insert_one(
        user.model_dump(exclude_none=True)
    )
    user_response = UserResponse(
        id=str(result.inse
Integrating MongoDB for NoSQL data storage
35
def get_user(user_id: str):
    db_user = user_collection.find_one(
        {
            "_id": ObjectId(user_id)
            if ObjectId.is_valid(user_id)
            else None
        }
    )
    if db_user is None:
        raise HTTPException(
            status_code=404,
            detail="User not found"
        )
    user_response = UserResponse(
        id=str(db_user["_id"]), **db_user
    )
    return user_response
If the user with the specified ID doesn’t exist, it will return a response status of 404.
In Mongo, the ID of the document is not stored in plain text, but in a 12-byte object. That’s why we 
need to initialize a dedicated bson.ObjectId when querying the database and explicitly decode 
to str when returning the value through the response.
You can then spin up the server with uvicorn:
$ uvicorn main:app
You can see the endpoints on the interactive documentation page: http://localhost:8000/
docs. Ensure you test every en
Working with Data
36
Working with data validation and serialization
Effective data validation stands as a cornerstone of robust web applications, ensuring that incoming 
data meets predefined criteria and remains safe for processing.
FastAPI harnesses the power of Pydantic, a Python library dedicated to data validation and serialization. 
By integrating Pydantic models, FastAPI streamlines the process of validating and serializing data, 
offering an elegant and efficient solution. This recipe shows how to utilize Pydantic models within 
FastAPI applications, exploring how they enable precise validation and seamless data serialization.
Getting ready
Pydantic models are essentially Python classes that define the structure and validation rules of your 
data. They use Python’s type annotations to validate that incoming data matches the expected format. 
When you use a Pydantic model in your FastAPI endpoints, FastAPI automatically validates incoming 
request data against the model.
In this
Working with data validation and serialization
37
Let’s say you try to add a user at the POST /user endpoint with an invalid user information body, 
as shown here:
{
  "name": "John Doe",
  "email": "invalidemail.com",
}
You will get a 422 response with a message body specifying the invalid fields.
Serialization and deserialization concepts
Serialization is the process of converting complex data types, such as Pydantic models or database 
models, into simpler formats such as JSON, which can be easily transmitted over the network. 
Deserialization is the reverse process, converting incoming data into complex Python types.
FastAPI handles serialization and deserialization automatically using Pydantic models. When you 
return a Pydantic model from an endpoint, FastAPI serializes it to JSON. Conversely, when you accept a 
Pydantic model as an endpoint parameter, FastAPI deserializes the incoming JSON data into the model.
For example, the get_user endpoint from the NoSQL example can be impr
Working with Data
38
This automatic serialization and deserialization make working with JSON data in FastAPI straightforward 
and type-safe.
Advanced validation techniques
Pydantic offers a range of advanced validation techniques that you can leverage in FastAPI. These 
include custom validators and complex data types.
Custom validators allow you to define complex validation logic for your models. You can create a 
custom validator by adding a method to your Pydantic model decorated with @field_validator.
For example, you could add a validator to ensure that a user’s age is within a certain range:
from pydantic import BaseModel, EmailStr, field_validator
class User(BaseModel):
    name: str
    email: EmailStr
    age: int
    @field_validator("age")
    def validate_age(cls, value):
        if value < 18 or value > 100:
            raise ValueError(
                "Age must be between 18 and 100"
            )
        return value
This validator ensures that the age field of the User
Working with file uploads and downloads
39
    email: EmailStr
    age: Optional[int]
    tweets: list[Tweet] | None = None
In this example, the User model has an optional tweets field, which is a list of Tweet objects.
By leveraging Pydantic’s advanced validation features, you can ensure that the data your FastAPI 
application processes is not only in the correct format but also adheres to your specific business logic 
and constraints. This provides a robust and flexible way to handle data validation and serialization 
in your FastAPI applications.
See also
You can learn more about the potential of Pydantic validators on the documentation page:
•	 Pydantic validators: https://docs.pydantic.dev/latest/concepts/validators/
Working with file uploads and downloads
Handling files is a common requirement in web applications, whether it’s uploading user avatars, 
downloading reports, or processing data files. FastAPI provides efficient and easy-to-implement 
methods for both uploading and do
Working with Data
40
In the main.py module, you can define the endpoint to upload files like so:
from fastapi import FastAPI, File, UploadFile
app = FastAPI()
@app.post("/uploadfile")
async def upload_file(
    file: UploadFile = File(...)):
    return {"filename": file.filename}
In this example, upload_file is an endpoint that accepts an uploaded file and returns its filename. 
The file is received in the form of an UploadFile object, which you can then save to disk or 
process further.
Implementing file uploads
When implementing file uploads, it’s essential to handle the file data correctly to ensure it is saved without 
corruption. Here’s an example of how you can save the uploaded file to a directory on your server.
Create a new folder project called uploads_downloads.
In the main.py module, create the upload_file endpoint:
import shutil
from fastapi import FastAPI, File, UploadFile
app = FastAPI()
@app.post("/uploadfile")
async def upload_file(
    file: UploadFile = File(...),
):
Working with file uploads and downloads
41
Important note
In a production environment, remember to handle exceptions and errors appropriately, 
especially for larger files
Create a text file called content.txt with some text in it.
Start the server by running the uvicorn main:app command. Then, access the interactive 
documentation; you’ll observe that the endpoint we just created for file uploads includes a mandatory 
field prompting users to upload a file. Upon testing the endpoint by uploading a file, you’ll discover 
the uploaded file residing within the designated uploads folder.
Managing file downloads and storage
Downloading files is the reverse process of uploading. In FastAPI, you can easily set up an endpoint to 
serve files for download. The FileResponse class is particularly useful for this purpose. It streams 
files from the server to the client, making it efficient for serving large files.
Here’s a simple file download endpoint:
from fastapi.responses import FileResponse

Working with Data
42
Handling file storage is another crucial aspect, especially when dealing with a large number of files or 
large file sizes. It’s often advisable to store files in a dedicated file storage system rather than directly 
on your web server. Cloud storage solutions such as Amazon S3, Google Cloud Storage, or Azure 
Blob Storage can be integrated into your FastAPI application for scalable and secure file storage. 
Additionally, consider implementing cleanup routines or archival strategies to manage the life cycle 
of the files you store.
See also
You can learn more about how to manage uploaded files on the official documentation page:
•	  FastAPI request files: https://fastapi.tiangolo.com/tutorial/request-
files/
Handling asynchronous data operations
Asynchronous programming is a core feature of FastAPI that allows you to develop highly efficient web 
applications. It allows your application to handle multiple tasks concurrently, making it particularly well-
suited for 
Handling asynchronous data operations
43
2.	
Now, let’s create an endpoint that sleeps for 1 second:
import time
@app.get("/sync")
def read_sync():
    time.sleep(2)
    return {
        "message": "Synchrounouns blocking endpoint"
    }
The sleeping operation represents the waiting time to get a response from the database in a 
real-life scenario.
3.	
Now, let’s create the same endpoint for the async def version. The sleeping operation will 
be the sleep function from the asyncio module:
import asyncio
@app.get("/async")
async def read_async():
    await asyncio.sleep(2)
    return {
        "message": 
        "Asynchronous non-blocking endpoint"
    }
Now, we have two endpoints, GET /sync and GET/async, that are similar except for the fact the 
second contains a non-blocking sleeping operation.
Once we have our application with the endpoints, let's create a separate Python script to measure the 
time to serve a traffic demand. Let’s call it timing_api_calls.py and start building it 
Working with Data
44
2.	
Now, let’s define the start of the server as a context manager:
from contextlib import contextmanager
from multiprocessing import Process
@contextmanager
def run_server_in_process():
    p = Process(target=run_server)
    p.start()
    time.sleep(2)  # Give the server a second to start
    print("Server is running in a separate process")
    yield
    p.terminate()
3.	
Now, we can define a function that makes n concurrent requests to a specified path endpoint:
async def make_requests_to_the_endpoint(
    n: int, path: str
):
    async with AsyncClient(
        base_url="http://localhost:8000"
    ) as client:
        tasks = (
            client.get(path, timeout=float("inf"))
            for _ in range(n)
        )
        await asyncio.gather(*tasks)
4.	
At this point, we can gather the operations into a main function, make n calls for each of the 
endpoints, and print the time to serve all the calls to the terminal:
async def main(n: int = 10):
    with run_
Handling asynchronous data operations
45
        )
        begin = time.time()
        await make_requests_to_the_endpoint(n,
                                            "/async")
        end = time.time()
        print(
            f"Time taken to make {n} requests "
            f"to async endpoint: {end - begin}
            seconds"
        )
5.	
Finally, we can run the main function in the asyncio event loop:
if __name__ == "__main__":
    asyncio.run(main())
Now that we have built our timing script, let's run it from the command terminal as follows:
$ python timing_api_calls.py
If you keep the default number of calls set to 10, your output will likely resemble the one on my machine:
Time taken to make 10 requests to sync endpoint: 2.3172452449798584 
seconds
Time taken to make 10 requests to async endpoint: 2.3033862113952637 
seconds
It looks like there is no improvement at all with using asyncio programming.
Now, try to set the number of calls to 100:
if __name__ == "__main__":
 
Working with Data
46
There’s more…
Asynchronous data operations can significantly improve the performance of your application, 
particularly when dealing with high-latency operations such as database access. By not blocking the 
main thread while waiting for these operations to complete, your application remains responsive and 
capable of handling other incoming requests or tasks.
If you already wrote CRUD operations synchronously, as we did in the previous recipe, Understanding 
CRUD operations with SQLAlchemy, implementing asynchronous CRUD operations in FastAPI 
involves modifying your standard CRUD functions so that they’re asynchronous with the 
sqlalchemy[asyncio] library. Similarly to SQL, for NoSQL, you will need to use the motor 
package, which is the asynchronous MongoDB client built on top of pymongo.
However, it’s crucial to use asynchronous programming judiciously. Not all parts of your application 
will benefit from asynchrony, and in some cases, it can introduce complexi
Securing sensitive data and best practices
47
To integrate async/await syntax with SQLAlchemy, you can have a look at documentation support:
•	 SQLAlchemy Asyncio: https://docs.sqlalchemy.org/en/20/orm/extensions/
asyncio.html
Chapter 6, Integrating FastAPI with SQL Databases, will focus on SQL database interactions. Here, 
you can find examples of integrating asyncio with sqlalchemy.
To integrate asyncio with MongoDB, you have to use a dedicated package called motor, which 
is built on top of pymongo:
•	 Motor asynchronous driver: https://motor.readthedocs.io/en/stable/
In Chapter 7, Integrating FastAPI with NoSQL Databases, you will find examples of motor integration 
with FastAPI.
Securing sensitive data and best practices
In the realm of web development, the security of sensitive data is paramount.
This recipe is a checklist of best practices for securing sensitive data in your FastAPI applications.
Getting ready
First and foremost, it’s crucial to understand the types of data that
Working with Data
48
How to do it…
Securely handling data in FastAPI involves more than just encryption; it encompasses a range of 
practices that are designed to protect data throughout its life cycle in your application.
Here is a list of good practices to apply when securing your application.
•	 Validation and sanitization: Use the Pydantic model to validate and sanitize incoming 
data, as shown in the Working with data validation and serialization recipe. Ensure the data 
conforms to expected formats and values, reducing the risk of injection attacks or malformed 
data causing issues.
Be cautious with data that will be output to users or logs. Sensitive information should be 
redacted or anonymized to prevent accidental disclosure.
•	 Access control: Implement robust access control mechanisms to ensure that users can only access 
the data they are entitled to. This can involve role-based access control (RBAC), permission 
checks and properly managing user authentication. You will d
Securing sensitive data and best practices
49
•	 Data retention and deletion: Have clear policies on data retention and deletion. When data is 
no longer needed, ensure it is deleted securely, leaving no trace in backups or logs.
•	 Monitoring and logging: Implement monitoring to detect unusual access patterns or potential 
breaches. However, be careful with what you log. Avoid logging sensitive data and ensure that 
logs are stored securely and are only accessible to authorized personnel.
By applying these practices, you can significantly enhance the security posture of your applications, 
protecting both your users and your organization from potential data breaches and ensuring compliance 
with data protection regulations. As a developer, understanding and implementing data security is 
not just a skill but a responsibility in today’s digital landscape. In the next chapter, we will learn how 
to build an entire RESTful API with FastAPI.

3
Building RESTful 
APIs with FastAPI
In this chapter, we delve into the essentials of building RESTful APIs. RESTful APIs are the backbone 
of web services, enabling applications to communicate and exchange data efficiently.
You will build a RESTful API for a Task Manager application. The application will interact with a CSV 
file, although the typical approach for such applications would be to use a database such as SQL or 
NoSQL. This approach is unconventional and not recommended for most scenarios due to scalability and 
performance limitations. However, in certain contexts, particularly in legacy systems or when dealing 
with large volumes of structured data files, managing data through CSV can be a practical solution.
Our Task Manager API will allow users to create, read, update, and delete (CRUD) tasks, each 
represented as a record in a CSV file. This example will provide insights into handling data in 
non-standard formats within FastAPI.
We will see how to test the API’s end
Building RESTful APIs with FastAPI
52
In this chapter, we’re going to cover the following recipes:
•	 Creating CRUD operations
•	 Creating RESTful endpoints
•	 Testing your RESTful API
•	 Handling complex queries and filtering
•	 Versioning your API
•	 Securing your API with OAuth2
•	 Documenting your API with Swagger and Redoc
Technical requirements
To fully engage with this chapter in our FastAPI Cookbook and effectively build RESTful APIs, you’ll 
need to have the following technologies and tools installed and configured:
•	 Python: Make sure you have a Python version higher than 3.9 in your environment.
•	 FastAPI: This should be installed with all required dependencies. If you haven’t done it from 
the previous chapters, you can do so simply from your terminal with the following command:
$ pip install fastapi[all]
•	 Pytest: You can install this framework by running the following:
$ pip install pytest
Note that it can be very useful to already have some knowledge of the Pytest fra
Creating CRUD operations
53
How to do it…
Let’s start by creating a project root directory called task_manager_app to host our code base 
for our application:
1.	
Move into the root project folder and create a tasks.csv file, which we will use as a database 
and put a few tasks inside:
id,title,description,status
1,Task One,Description One,Incomplete
2,Task Two,Description Two,Ongoing
2.	
Then, create a file called models.py, containing the Pydantic models that we will use internally 
for the code. It will look like the following:
from pydantic import BaseModel
class Task(BaseModel):
    title: str
    description: str
    status: str
class TaskWithID(Task):
    id: int
We created two separate classes for task objects because id won’t be used all along the code.
3.	
In a new file called operations.py, we will define the function that interacts with our database.
We can start creating the CRUD operation
Create a function to retrieve all the tasks from a .csv file:
import csv
from typing
Building RESTful APIs with FastAPI
54
    with open(DATABASE_FILENAME) as csvfile:
        reader = csv.DictReader(
            csvfile,
        )
        return [TaskWithID(**row) for row in reader]
4.	
Now, we need to create a function to read a specific task based on id:
def read_task(task_id) -> Optional[TaskWithID]:
    with open(DATABASE_FILENAME) as csvfile:
        reader = csv.DictReader(
            csvfile,
        )
        for row in reader:
            if int(row["id"]) == task_id:
                return TaskWithID(**row)
5.	
To write a task, we need a strategy to assign a new id to the task that will written into the database.
A good strategy can be to implement a logic based on the IDs already present in the database, 
then write the task into our CSV file, and group both operations into a new function. We can 
split the create task operation into three functions.
First, let’s create the function that retrieves the new ID based on the existing ones in the database:
def 
Creating CRUD operations
55
        writer = csv.DictWriter(
            file,
            fieldnames=column_fields,
        )
        writer.writerow(task.model_dump())
After that, we can leverage these last two functions to define the function that creates the task:
def create_task(
    task: Task
) -> TaskWithID:
    id = get_next_id()
    task_with_id = TaskWithID(
        id=id, **task.model_dump()
    )
    write_task_into_csv(task_with_id)
    return task_with_id
6.	
Then, let’s create the function to modify the task:
def modify_task(
    id: int, task: dict
) -> Optional[TaskWithID]:
    updated_task: Optional[TaskWithID] = None
    tasks = read_all_tasks()
    for number, task_ in enumerate(tasks):
        if task_.id == id:
            tasks[number] = (
                updated_task
            ) = task_.model_copy(update=task)
    with open(
        DATABASE_FILENAME, mode="w", newline=""
    ) as csvfile:  # rewrite the file
        writer = csv.DictWriter(
            csvfi
Building RESTful APIs with FastAPI
56
7.	
Finally, let’s create the function to remove the task with a specific id:
def remove_task(id: int) -> bool:
    deleted_task: Optional[Task] = None
    tasks = read_all_tasks()
    with open(
        DATABASE_FILENAME, mode="w", newline=""
    ) as csvfile:  # rewrite the file
        writer = csv.DictWriter(
            csvfile,
            fieldnames=column_fields,
        )
        writer.writeheader()
        for task in tasks:
            if task.id == id:
                deleted_task = task
                continue
            writer.writerow(task.model_dump())
    if deleted_task:
        dict_task_without_id = (
            deleted_task.model_dump()
        )
        del dict_task_without_id["id"]
        return Task(**dict_task_wihtout_id)
You’ve just created the basic CRUD operations. We are now ready to expose those operations through 
the API endpoints.
How it works...
The structure of your API is fundamental in RESTful design. It i
Creating RESTful Endpoints
57
Each endpoint represents a specific function in the API, clearly defined and purpose driven. FastAPI’s 
routing system allows us to map these operations to Python functions easily.
Exercise
Try to write your unit tests for each one of the CRUD operations. If you follow along with the 
GitHub repository, you can find the tests in the Chapter03/task_manager_rest_api/
test_operations.py file.
Creating RESTful Endpoints
Now, we will create the routes to expose each of the CRUD operations with a specific endpoint. In 
this recipe, we will see how FastAPI leverages Python type annotations to define expected request and 
response data types, streamlining the process of validation and serializing data.
Getting ready…
Before starting the recipe, make sure you know how to set up your local environment and create a basic 
FastAPI server. You can review it in the Creating a new FastAPI project and Understanding FastAPI 
basics recipes in Chapter 1, First Steps with Fa
Building RESTful APIs with FastAPI
58
@app.get("/tasks", response_model=list[TaskWithID])
def get_tasks():
    tasks = read_all_tasks()
    return tasks
2.	
Now, let’s write the endpoint to read a specific task based on id:
@app.get("/task/{task_id}")
def get_task(task_id: int):
    task = read_task(task_id)
    if not task:
        raise HTTPException(
            status_code=404, detail="task not found"
        )
    return task
3.	
The endpoint to add a task will be as follows:
from operations import create_task
@app.post("/task", response_model=TaskWithID)
def add_task(task: Task):
    return create_task(task)
4.	
To update the task, we can modify each field (description, status, or title). To do 
this, we create a specific model to be used in the body called UpdateTask. The endpoint 
will look like this:
from operations import modify_task
class UpdateTask(BaseModel):
    title: str | None = None
    description: str | None = None
    status: str | None = None
@app.put("/task/{task
Testing your RESTful API
59
        task_update.model_dump(exclude_unset=True),
    )
    if not modified:
        raise HTTPException(
            status_code=404, detail="task not found"
        )
    return modified
5.	
Finally, here is the endpoint to delete a task:
from operations import remove_task
@app.delete("/task/{task_id}", response_model=Task)
def delete_task(task_id: int):
    removed_task = remove_task(task_id)
    if not removed_task:
        raise HTTPException(
            status_code=404, detail="task not found"
        )
    return removed_task
You have just implemented the operations to interact with the CSV file used as a database.
From a command terminal at the project root folder level, spin up the server with the uvicorn command:
$ uvicorn main:app
In the browser, go to http://localhost:8000/docs and you will see the endpoints of your 
RESTful API that you just made.
You can experiment by creating some tasks, then listing them, updating them, and deleting some o
Building RESTful APIs with FastAPI
60
Getting ready…
If not done yet, ensure you have pytest installed in your environment by running:
$ pip install pytest
It’s a good practice in testing to use a dedicated database to avoid interaction with the production one. 
To accomplish this, we will create a test fixture that generates the database before each test.
We will define this in a conftest.py module so that the fixture is applied to all tests under the 
project’s root folder. Let’s create the module in the project root folder and start by defining a list of 
test tasks and the name of the CSV file used for the tests:
TEST_DATABASE_FILE = "test_tasks.csv"
TEST_TASKS_CSV = [
    {
        "id": "1",
        "title": "Test Task One",
        "description": "Test Description One",
        "status": "Incomplete",
    },
    {
        "id": "2",
        "title": "Test Task Two",
        "description": "Test Description Two",
        "status": "Ongoing",
    },
]
TEST_TASKS = [
    {**task_js
Testing your RESTful API
61
from unittest.mock import patch
import pytest
@pytest.fixture(autouse=True)
def create_test_database():
    database_file_location = str(
        Path(__file__).parent / TEST_DATABASE_FILE
    )
    with patch(
        "operations.DATABASE_FILENAME",
        database_file_location,
    ) as csv_test:
        with open(
            database_file_location, mode="w", newline=""
        ) as csvfile:
            writer = csv.DictWriter(
                csvfile,
                fieldnames=[
                    "id",
                    "title",
                    "description",
                    "status",
                ],
            )
            writer.writeheader()
            writer.writerows(TEST_TASKS_CSV)
            print("")
        yield csv_test
        os.remove(database_file_location)
Since the fixture is defined in a conftest.py module, each test module will automatically import it.
Now, we can proceed with creating the actual unit test functio
Building RESTful APIs with FastAPI
62
In a new module called test_main.py, let’s define our test client:
from main import app
from fastapi.testclient import TestClient
client = TestClient(app)
We can create the tests for each endpoint as follows.
1.	
Let’s start with the GET /tasks endpoint, which lists all the tasks in the database:
from conftest import TEST_TASKS
def test_endpoint_read_all_tasks():
    response = client.get("/tasks")
    assert response.status_code == 200
    assert response.json() == TEST_TASKS
We are asserting the response’s status code and the json body.
2.	
As easy as that, we can go on by creating the test for GET /tasks/{task_id} to read a 
task with a specific id:
def test_endpoint_get_task():
    response = client.get("/task/1")
    assert response.status_code == 200
    assert response.json() == TEST_TASKS[0]
    response = client.get("/task/5")
    assert response.status_code == 404
Besides the 200 status code for an existing task, we also asserted the stat
Testing your RESTful API
63
        "description": "will be done",
        "status": "Ready",
    }
    response = client.post("/task", json=task)
    assert response.status_code == 200
    assert response.json() == {**task, "id": 3}
    assert len(read_all_tasks()) == 3
4.	
The test for the PUT /tasks/{task_id} endpoint to modify a task will then be the following:
from operations import read_task
def test_endpoint_modify_task():
    updated_fields = {"status": "Finished"}
    response = client.put(
        "/task/2", json=updated_fields
    )
    assert response.status_code == 200
    assert response.json() == {
         *TEST_TASKS[1],
         *updated_fields,
    }
    response = client.put(
        "/task/3", json=updated_fields
    )
    assert response.status_code == 404
5.	
Finally, we test the DELETE /tasks/{task_id} endpoint to delete a task:
def test_endpoint_delete_task():
    response = client.delete("/task/2")
    assert response.status_code == 200
    expected_response =
Building RESTful APIs with FastAPI
64
You’ve just written all the unit tests for each of the API endpoints.
You can now run the tests from the project root folder by running in the terminal, or with the GUI 
support of your favorite editor:
$ pytest .
Pytest will collect all the tests and run them. If everything is correctly done, you will see a message 
that says you got a 100% score in the output of the console if you have written the tests correctly.
See also
You can check test fixtures in the Pytest documentation:
•	 Pytest Fixtures Reference: https://docs.pytest.org/en/7.1.x/reference/
fixtures.html
You can dig into FastAPI testing tools and the TestClient API in the official documentation:
•	 FastAPI Testing: https://fastapi.tiangolo.com/tutorial/testing/
•	 FastAPI TestClient: https://fastapi.tiangolo.com/reference/testclient/
Handling complex queries and filtering
In any RESTful API, providing the functionality to filter data based on certain criteria is essential. 
In this rec
Handling complex queries and filtering
65
The endpoint will then look like the following:
@app.get("/tasks", response_model=list[TaskWithID])
def get_tasks(
    status: Optional[str] = None,
    title: Optional[str] = None,
):
    tasks = read_all_tasks()
    if status:
        tasks = [
            task
            for task in tasks
            if task.status == status
        ]
    if title:
        tasks = [
            task for task in tasks if task.title == title
        ]
    return tasks
The two parameters can be optionally specified to filter the tasks that match their value.
Next, we implement a search functionality. Beyond basic filtering, implementing a search functionality 
can significantly improve the usability of an API. We’ll add a search feature that allows users to find 
tasks based on a keyword present in the title or description in a new endpoint:
@app.get("/tasks/search", response_model=list[TaskWithID])
def search_tasks(keyword: str):
    tasks = read_all_tasks()

Building RESTful APIs with FastAPI
66
To start the server as usual, run this command from the command line:
$ uvicorn main:app
Then, go to the interactive documentation address at http://localhost:8000/docs, and 
you will see the new endpoint we’ve just made.
Play around by specifying some keywords that could be in the title or the description of one of your tasks.
Versioning your API
API versioning is essential in maintaining and evolving web services without disrupting the existing 
users. It allows developers to introduce changes, improvements, or even breaking changes while 
providing backward compatibility. In this recipe, we will implement versioning in our Task Manager API.
Getting ready…
To follow the recipe, you will need to have endpoints already defined. If you don’t have them, you can 
first check the Creating RESTful endpoints recipe.
How to do it...
There are several strategies for API versioning. We will use the most common approach, URL path 
versioning, for our API.
Le
Versioning your API
67
2.	
In the operations.py module, let’s create a new function called read_all_tasks_v2, 
which reads all the tasks, and add the priority field:
from models import TaskV2WIthID
def read_all_tasks_v2() -> list[TaskV2WIthID]:
    with open(DATABASE_FILENAME) as csvfile:
        reader = csv.DictReader(
            csvfile,
        )
        return [TaskV2WIthID(**row) for row in reader]
3.	
We have now all we need to create version two of read_all_tasks function. We will do 
this in the main.py module:
from models import TaskV2WithID
@app.get(
    "/v2/tasks",
    response_model=list[TaskV2WithID]
)
def get_tasks_v2():
    tasks = read_all_tasks_v2()
    return tasks
You’ve just created version two of the endpoint. In this way, you can develop and improve your API 
with several versions of your endpoint.
To test it, let's modify our tasks.csv file by manually adding the new field to test the new endpoint:
id,title,description,status,priority
1,Task One,Description On
Building RESTful APIs with FastAPI
68
Exercise
You might have noticed that using a CSV file as a database might not be the most reliable 
solution. If the process crashes during an update or removal, you can lose all of the data. So, 
improve the API with a newer version of the endpoints that use operational functions that 
interact with an SQLite database.
There’s more…
When you version an API, you are essentially providing a way to differentiate between different 
releases or versions of your API, allowing clients to choose which version they want to interact with.
Besides the URL-based approach that we used in the recipe, there are other common approaches to 
API versioning, such as the following:
•	 Query parameter versioning: Version information is passed as a query parameter in the API 
request. For example, see the following:
https://api.example.com/resource?version=1
This method keeps the base URL uniform across versions.
•	 Header versioning: The version is specified in a cust
Securing your API with OAuth2
69
See also
You can have a look at an interesting article from the Postman blog on API versioning strategies:
•	 Postman Blog API Versioning: https://www.postman.com/api-platform/
api-versioning/
Securing your API with OAuth2
In web applications, securing endpoints from unauthorized users is crucial. OAuth2 is a common 
authorization framework that enables applications to be accessed by user accounts with restricted 
permissions. It works by issuing tokens instead of credentials. This recipe will show how to use OAuth2 
in our Task Manager API to protect endpoints.
Getting ready…
FastAPI provides support for OAuth2 with a password, including the use of external tokens. Data 
compliance regulations require that passwords are not stored in plain text. Instead, a usual method 
is to store the outcome of the hashing operation, which changes the plain text into a string that is not 
readable by humans and cannot be reversed.
Important note
With the only purpose
Building RESTful APIs with FastAPI
70
2.	
Passwords should not be stored in plain text, but encrypted or hashed. To demonstrate the 
feature, we fake the hashing mechanism by inserting "hashed" before the password string:
def fakely_hash_password(password: str):
    return f"hashed{password}"
3.	
Let’s create the classes to handle the users and a function to retrieve the user from the dict 
database we created:
class User(BaseModel):
    username: str
class UserInDB(User):
    hashed_password: str
def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)
4.	
Using a similar logic to what we’ve just used for hashing, let’s make a fake token generator and 
a fake token resolver:
def fake_token_generator(user: UserInDB) -> str:
    # This doesn't provide any security at all
    return f"tokenized{user.username}"
def fake_token_resolver(
    token: str
) -> UserInDB | None:
    if token.startswith("tokenized"):
        use
Securing your API with OAuth2
71
5.	
Now, let’s create a function to retrieve the user from the token. To this, we will make use of the 
Depends class to use dependency injection provided by FastAPI (see https://fastapi.
tiangolo.com/tutorial/dependencies/), with the OAuthPasswordBearer 
class to handle the token:
from fastapi import Depends, HTTPException, status
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
def get_user_from_token(
    token: str = Depends(oauth2_scheme),
) -> UserInDB:
    user = fake_token_resolver(token)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=(
                "Invalid authentication credentials"
            ),
            headers={"WWW-Authenticate": "Bearer"},
        )
    return user
oauth2scheme contains the /token URL endpoint that will be used by the interactive 
documentation to authenticate the browser.
Important note
We have used a dependency injection to retrieve th
Building RESTful APIs with FastAPI
72
)
@app.post("/token")
async def login(
    form_data: OAuth2PasswordRequestForm = Depends(),
):
    user_dict = fake_users_db.get(form_data.username)
    if not user_dict:
        raise HTTPException(
            status_code=400,
            detail="Incorrect username or password",
        )
    user = UserInDB(**user_dict)
    hashed_password = fakely_hash_password(
        form_data.password
    )
    if not hashed_password == user.hashed_password:
        raise HTTPException(
            status_code=400,
            detail="Incorrect username or password",
        )
    token = fake_token_generator(user)
    return {
        "access_token": token,
        "token_type": "bearer"
    }
We now have all we need to create a secured endpoint with OAuth2 authentication.
7.	
The endpoint we are going to create will return information about the current user from the 
token provided. If the token does not have authorization, it will return a 400 exception
Securing your API with OAuth2
73
Let's now test our secured endpoint. From the command line terminal at the project root folder level, 
spin up the server by running:
$ uvicorn main:app
Then, open the browser, go to http://localhost:8000/docs, and you will notice the new 
token and users/me endpoints in the interactive documentation.
You might notice a little padlock icon on the users/me endpoint. If you click on it, you will see a 
form window that allows you to get the token and store it directly in your browser, so you don’t have 
to provide it each time you call the secured endpoint.
Exercise
You’ve just learned how to create a secured endpoint for your RESTful API. Now, try to secure 
some of the endpoints you created in the previous recipes.
There’s more…
With OAuth2, we can define a scope parameter, which is used to specify the level of access that an 
access token grants to a client application when it is used to access a protected resource. Scopes can 
be used to define what a
Building RESTful APIs with FastAPI
74
Documenting your API with Swagger and Redoc
FastAPI automatically generates documentation for your API using Swagger UI and Redoc, when 
spinning the server.
This documentation is derived from your route functions and Pydantic models, making it incredibly 
beneficial for both development and consumption by frontend teams or API consumers.
In this recipe, we will see how to customize the documentation’s specific needs.
Getting ready…
By default, FastAPI provides two documentation interfaces:
•	 Swagger UI: Accessible at /docs endpoint (e.g., http://127.0.0.1:8000/docs)
•	 Redoc: Accessible at /redoc endpoint (e.g., http://127.0.0.1:8000/redoc)
These interfaces offer dynamic documentation where users can see and test the API endpoints and 
their details. However, both pieces of documentation can be modified.
How to do it...
FastAPI allows the customization of Swagger UI. You can add metadata, customize the look, and add 
additional documentation thro
Documenting your API with Swagger and Redoc
75
In this case, you can use the utils, module provided by FastAPI to retrieve the OpenAPI schema 
of the Swagger UI in a dict object as follows:
from fastapi.openapi.utils import get_openapi
def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema
    openapi_schema = get_openapi(
        title="Customized Title",
        version="2.0.0",
        description="This is a custom OpenAPI schema",
        routes=app.routes,
    )
    del openapi_schema["paths"]["/token"]
    app.openapi_schema = openapi_schema
    return app.openapi_schema
app = FastAPI(
    title="Task Manager API",
    description="This is a task management API",
    version="0.1.0",
)
app.openapi = custom_openapi
That’s all you need to customize your API documentation.
If you spin up the server with the uvicorn main:app command and go to one of the two 
documentation pages, the /token endpoint won’t appear anymore.
You are now able to customize your A

4
Authentication and 
Authorization
In this chapter of our FastAPI Cookbook, we will delve into the critical realms of authentication and 
authorization, laying the foundation to secure your web applications against unauthorized access.
As we navigate through this chapter, you’ll embark on a practical journey to implement a comprehensive 
security model in your FastAPI applications. From the basics of user registration and authentication 
to the integration of sophisticated OAuth2 protocols with JSON Web Token (JWT) for enhanced 
security, this chapter covers it all.
We will create the essential components of software as a service (SaaS) to help you learn practically 
how to establish user registration systems, verify users, and handle sessions efficiently. We’ll also 
show you how to apply role-based access control (RBAC) to adjust user permissions and protect 
API endpoints with API key authentication. The incorporation of third-party authentication using 
external login services, su
Authentication and Authorization
78
Technical requirements
To dive into the chapter and follow along with recipes on authentication and authorization, ensure 
your setup includes the following essentials:
•	 Python: Install a Python version higher than 3.9 in your environment.
•	 FastAPI: This should be installed with all required dependencies. If you didn’t do so during 
the previous chapters, you can simply do it from your terminal:
$ pip install fastapi[all]
The code used in the chapter is hosted on GitHub at https://github.com/PacktPublishing/
FastAPI-Cookbook/tree/main/Chapter04.
Setting up a virtual environment for the project within the project root folder is also recommended 
to manage dependencies efficiently and maintain project isolation. Within your virtual environment, 
you can install all the dependencies at once by using the requirements.txt file, provided in the 
GitHub repository in the project folder:
pip install –r requirements.txt
Since the interactive Swagger docum
Setting up user registration
79
You will also need to install a version of sqlalchemy higher than 2.0.0 to follow along with the 
code in the GitHub repository:
$ pip install sqlalchemy>=2.0.0
Our environment is now ready to implement the user registration in our SaaS.
How to do it…
Before starting the implementation, we need to set up the database to store our users.
We need to set up a SQLite database with sqlalchemy for the application to store user credentials.
You need to do the following:
•	 Set up a User class to map the users table in the SQL database. The table should contain the 
id, username, email, and hashed_password fields.
•	 Establish the connection between the application and the database.
First let's create our project root folder called saas_app. Then you can refer to the Setting up SQL 
databases recipe in Chapter 2, Working with Data, or copy the database.py and db_connection.
py modules from the GitHub repository under your root folder.
With the database session s
Authentication and Authorization
80
def add_user(
    session: Session,
    username: str,
    password: str,
    email: str,
) -> User | None:
    hashed_password = pwd_context.hash(password)
    db_user = User(
        username=username,
        email=email,
        hashed_password=hashed_password,
    )
    session.add(db_user)
    try:
        session.commit()
        session.refresh(db_user)
    except IntegrityError:
        session.rollback()
        return
    return db_user
InegrityError will take into account the attempt to add a username or email that already exists.
We now have to define our endpoint, but first, we need to set up our server and initialize the database 
connection. We can do it in the main.py module, as follows:
from contextlib import (
    asynccontextmanager,
)
from fastapi import  FastAPI
from db_connection import get_engine
@asynccontextmanager
async def lifespan(app: FastAPI):
    Base.metadata.create_all(bind=get_engine())
    yield
app = FastAPI(
Setting up user registration
81
    title="Saas application", lifespan=lifespan
)
We use the lifespan parameter of the FastAPI object to instruct the server to sync our database 
class, User, with the database when it starts up.
In addition, we can create a separate module, responses.py, to keep the response classes used for 
different endpoints. Feel free to create your own or copy the one provided in the GitHub repository.
We can now write the suitable endpoint to sign up a user in the same main.py module:
from typing import Annotated
from sqlalchemy.orm import Session
from fastapi import Depends, HTTPException, status
from models import Base
from db_connection import get_session
from operations import add_user
@app.post(
    "/register/user",
    status_code=status.HTTP_201_CREATED,
    response_model=ResponseCreateUser,
    responses={
        status.HTTP_409_CONFLICT: {
            "description": "The user already exists"
        }
    },
)
def register(
    user: UserCreateBody,

Authentication and Authorization
82
        username=user.username, email=user.email
    )
    return {
        "message": "user created",
        "user": user_response,
    }
We have just implemented a basic mechanism to register and store users in our SaaS database.
How it works...
The endpoint will accept a JSON body containing a username, email, and password.
If the username or email already exists, a 409 response will be returned, and user creation will 
be disallowed.
To test this, at the project root level, spin up the server by running the following:
$ uvicorn main:app
Then, connect with your browser at localhost:8000/docs and check the endpoint we just 
created in the Swagger documentation. Feel free to play around with it.
Exercise
Create proper tests for both the add_user function and the /register/user endpoint, 
such as the following:
def test_add_user_into_the_database(session):
    user = add_user(…
    # fill in the test
def test_endpoint_add_basic_user(client):
    res
Working with OAuth2 and JWT for authentication
83
See also
The bcrypt library allows you to add several layers of security to your hashing functions, such as salt 
and additional keys. Feel free to have a look at the source code on GitHub:
•	 Bcrypt GitHub Repository: https://github.com/pyca/bcrypt/
Also, you can find some interesting examples of how to use it at the following:
•	 Hashing Passwords in Python with Bcrypt: https://www.geeksforgeeks.org/
hashing-passwords-in-python-with-bcrypt/
Working with OAuth2 and JWT for authentication
In this recipe, we’ll integrate OAuth2 with JWTs for secure user authentication in your application. 
This approach improves security by utilizing tokens instead of credentials, aligning with modern 
authentication standards.
Getting ready
Since we will use a specific library to manage JWT, ensure you have the necessary dependencies 
installed. If you haven’t installed the packages from requirements.txt, run the following:
$ pip install python-jose[cry
Authentication and Authorization
84
    username_or_email: str,
    password: str,
) -> User | None:
    try:
        validate_email(username_or_email)
        query_filter = User.email
    except EmailNotValidError:
        query_filter = User.username
    user = (
        session.query(User)
        .filter(query_filter == username_or_email)
        .first()
    )
    if not user or not pwd_context.verify(
        password, user.hashed_password
    ):
        return
    return user
The function can validate the input based on either the username or email.
2.	
Let’s define the functions to create and decode the access token in the same module 
(create_access_token and decode_access_token).
To create the access token, we will need to specify a secret key, the algorithm used to generate 
it, and the expiration time, as follows:
SECRET_KEY = "a_very_secret_key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30
Then, the create_access_token_function is as follows:
from jose import jwt

Working with OAuth2 and JWT for authentication
85
To decode the access token, we can use a support function, get_user, that returns the User 
object by the username. You can do it on your own in the operations.py module or take 
it from the GitHub repository.
The function to decode the token will be as follows:
from jose import JWTError
def decode_access_token(
    token: str, session: Session
) -> User | None:
    try:
        payload = jwt.decode(
            token, SECRET_KEY, algorithms=[ALGORITHM]
        )
        username: str = payload.get("sub")
    except JWTError:
        return
    if not username:
        return
    user = get_user(session, username)
    return user
3.	
We can now proceed to create the endpoint to retrieve the token in the same module, security.py, 
with the APIRouter class:
from fastapi import (
    APIRouter,
    Depends,
    HTTPException,
    status,
)
from fastapi.security import (
    OAuth2PasswordRequestForm,
)
router = APIRouter()
class Token(Base
Authentication and Authorization
86
    "/token",
    response_model=Token,
    responses=..., # document the responses
)
def get_user_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    session: Session = Depends(get_session),
):
    user = authenticate_user(
        session,
        form_data.username,
        form_data.password
    )
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
        )
    access_token = create_access_token(
        data={"sub": user.username}
    )
    return {
        "access_token": access_token,
        "token_type": "bearer",
    }
4.	
Then, we can now create an OAuth2PasswordBearer object for the POST /token 
endpoint to obtain the access token:
from fastapi.security import (
    OAuth2PasswordBearer,
)
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
5.	
Finally, we can create the /users/me endpoint that returns the credentia
Working with OAuth2 and JWT for authentication
87
    session: Session = Depends(get_session),
):
    user = decode_access_token(token, session)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not authorized",
        )
    return {
        "description": f"{user.username} authorized",
    }
6.	
Now, let’s import those endpoints into the FastAPI server in main.py. Right after defining 
the FastAPI object, let’s add the router, as follows:
import security
# rest of the code
app.include_router(security.router)
We have just defined the authentication mechanism for our SaaS.
How it works…
Now, spin up the server by running the following code from the terminal at the project root folder level:
$ uvicorn main:app
Go to the Swagger documentation address in your browser (localhost:8000/docs) and you 
will see the new endpoints, POST /token and GET /users/me.
You need the token to call the second endpoint, which you ca
Authentication and Authorization
88
See also
You can gain a better understanding of the OAuth2 framework by reading this article:
•	 Introduction to OAuth2: https://www.digitalocean.com/community/tutorials/
an-introduction-to-oauth-2
Also, you can have a look at the protocol definition for JWTs at the following:
•	 JWT IETF Document: https://datatracker.ietf.org/doc/html/rfc7519
Setting up RBAC
RBAC is a method of regulating access to resources based on the roles of individual users within 
an organization. In this recipe, we’ll implement RBAC in a FastAPI application to manage user 
permissions effectively.
Getting ready
Since we will expand our database to accommodate role definitions, make sure you have completed 
the Setting up user registration recipe before diving into this.
To set up access control, we first need to define a variety of roles that we can allocate to. Let’s follow 
these steps to do it.
1.	
In the module.py module, we can define a new class called Role and add it 
Setting up RBAC
89
2.	
Then, in the operations.py module, we will modify the add_user function in 
operations.py to accept a parameter to define the user role; the default value will be the 
basic role:
from models import Role
def add_user(
    session: Session,
    username: str,
    password: str,
    email: str,
    role: Role = Role.basic,
) -> User | None:
    hashed_password = pwd_context.hash(password)
    db_user = User(
        username=username,
        email=email,
        hashed_password=hashed_password,
        role=role,
    )
    # rest of the function
3.	
Let’s create a new module called premium_access.py and define the endpoint through 
a new router to sign up a premium user, which will look a lot like the endpoint to sign up a 
basic user:
@router.post(
    "/register/premium-user",
    status_code=status.HTTP_201_CREATED,
    response_model=ResponseCreateUser,
    responses=..., # document responses
)
def register_premium_user(
    user: UserCreateBody,
    session: 
Authentication and Authorization
90
            status.HTTP_409_CONFLICT,
            "username or email already exists",
        )
    user_response = UserCreate(
        username=user.username,
        email=user.email,
    )
    return {
        "message": "user created",
        "user": user_response,
    }
In the previous code snippet, the imports and the router definition are skipped, since they are 
similar to the ones used in other modules.
4.	
Let’s add the router to our app class in the main.py module:
import security
import premium_access
# rest of the code
app.include_router(security.router)
app.include_router(premium_access.router)
We have now all the elements to implement RBAC in our SaaS application.
How to do it...
Let’s create two endpoints, one accessible for all the users and one reserved only for premium user. 
Let's make the endpoints through the following steps.
1.	
First, let’s create two helper functions, get_current_user and get_premium_user, 
to retrieve each 
Setting up RBAC
91
from sqlalchemy.orm import Session
from db_connection import get_session
from models import Role
from security import (
    decode_access_token,
    oauth2_scheme
)
Then, we create the request model that we will use with the endpoints:
class UserCreateResquestWithRole(BaseModel):
    username: str
    email: EmailStr
    role: Role
Then, we define a support function to retrieve the user based on the token:
def get_current_user(
    token: str = Depends(oauth2_scheme),
    session: Session = Depends(get_session),
) -> UserCreateRequestWithRole:
    user = decode_access_token(token, session)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not authorized",
        )
    return UserCreateRequestWithRole(
        username=user.username,
        email=user.email,
        role=user.role,
    )
We can then leverage this function to shortlist premium users only:
def get_premium_user(
    current_user
Authentication and Authorization
92
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not authorized",
        )
    return current_user
2.	
Now, we can use the functions to create the respective endpoints with the router in the same 
module. First, we define a welcome page for all the users:
router = APIRouter()
@router.get(
    "/welcome/all-users",
    responses=..., # document responses
)
def all_users_can_access(
    user: Annotated[get_current_user, Depends()]
):
    return {
        f"Hello {user.username}, "
        "welcome to your space"
    }
Then, we define the endpoint, allowing only premium users:
@router.get(
    "/welcome/premium-user",
    responses={
        status.HTTP_401_UNAUTHORIZED: {
            "description": "User not authorized"
        }
    },
)
def only_premium_users_can_access(
    user: UserCreateResponseWithRole = Depends(
        get_premium_user
    ),
):
    return {
        f"Hello {user.username}, "
        "Welcome to 
Setting up RBAC
93
3.	
Let’s add the router we create in main.py:
import security
import premium_access
import rbac
# rest of the module
app.include_router(premium_access.router)
app.include_router(rbac.router)
# rest of the module
We have just implemented two endpoints with permissions based on the use role.
To test our endpoints, start the server from the command line:
$ uvicorn main:app
Then, from your browser, go to the Swagger page at http://localhost:8000/docs, and you 
can see the new endpoints just created.
A way to experiment is to create a basic and a premium user and use the corresponding endpoints. After 
you have made the users, you can try using the GET welcome/all-users and GET /welcome/
premium-user endpoints with both roles and see that the response matches the role’s expectations.
In this recipe, you just made simple endpoints that are available based on the user role. You can also 
play around with making more roles and endpoints.
There’s more…
Another way to apply R
Authentication and Authorization
94
Using third-party authentication
Incorporating third-party authentication into your FastAPI application allows users to log in using 
their existing social media accounts, such as Google or Facebook. This recipe guides you through 
the process of integrating GitHub third-party login, enhancing user experience by simplifying the 
sign-in process.
Getting ready
We’ll focus on integrating GitHub OAuth2 for authentication. GitHub provides comprehensive 
documentation and a well-supported client library that simplifies the integration process.
You will need the httpx package in your environment, so if you haven’t installed it with the 
requirements.txt, you can do it by running the following:
$ pip install httpx
You will need also a GitHub account set up. If you don’t have one, create one; you can find a comprehensive 
guide on the official documentation at https://docs.github.com/en/get-started/
start-your-journey/creating-an-account-on-github.
Then, you
Using third-party authentication
95
How to do it...
Let’s start by creating a new module called third_party_login.py to store helper data and 
functions for the GitHub authentication. Then let's continue as follows.
1.	
Within the third_party_login.py module, you can define the variables used for 
the authentication:
GITHUB_CLIENT_ID = "your_github_client_id"
GITHUB_CLIENT_SECRET = (
    "your_github_client_secret"
)
GITHUB_REDIRECT_URI = (
    "http://localhost:8000/github/auth/token"
)
GITHUB_AUTHORIZATION_URL = (
    "https://github.com/login/oauth/authorize"
)
For GITHUB_CLIENT_ID and GITHUB_CLIENT_SECRET, use the values of your OAuth app.
Warning
In a production environment, make sure to not hardcode any username or client ID in your 
code base.
2.	
Then, still in the third_party_login.py module, let’s define a helper function, 
resolve_github_token, that resolves the GitHub token and returns information about 
the user:
import httpx
from fastapi import Depends, HTTPException
from
Authentication and Authorization
96
        "https://api.github.com/user",
        headers={"Authorization": access_token},
    ).json()
    username = user_response.get("login", " ")
    user = get_user(session, username)
    if not user:
        email = user_response.get("email", " ")
        user = get_user(session, email)
    # Process user_response
    # to log the user in or create a new account
    if not user:
        raise HTTPException(
            status_code=403, detail="Token not valid"
        )
    return user
3.	
In a new module called github_login.py, we can start creating the endpoints used for the 
GitHub authentication. Let’s create a new router and the github_login endpoint that will 
return the URL used by the frontend to redirect the user to the GitHub login page:
import httpx
from fastapi import APIRouter, HTTPException, status
from security import Token
from third_party_login import (
    GITHUB_AUTHORIZATION_URL,
    GITHUB_CLIENT_ID,
    GITHUB_CLIENT_SECRET,
Using third-party authentication
97
4.	
Now, let’s add the router to the server in the main.py module:
import github_login
# rest of the module
app.include_router(github_login.router)
# rest of the module
5.	
Spin up the server with the same command, uvicorn main:app, and call the endpoint 
GET /auth/url we have just created. You will have a similar link in the response: https://
github.com/login/oauth/authorize?client_id=your_github_client_id.
This link is used by GitHub for the authentication. The redirection is managed by the frontend 
and is out of the scope of this book.
6.	
After validating the login, you will be redirected to a 404 page. This is because we still haven’t 
created the callback endpoint in our application. Let’s do so in the github_login.py module:
@router.get(
    "/github/auth/token",
    response_model=Token,
    responses=..., # add responses documentation
)
async def github_callback(code: str):
    token_response = httpx.post(
        "https://github.com/login
Authentication and Authorization
98
    )
    return {
        "access_token": access_token,
        "token_type": token_type,
    }
The endpoint we just created returns the actual access token.
7.	
If you restart the server and try to validate the GitHub login again with the link provded by 
the GET /auth/url endpoint, you will receive a response containing the token similar to 
the following:
{
    "access_token": "gho_EnHbcmHdCHD1Bf2QzJ2B6gyt",
    "token_type": "bearer"
}
8.	
The last piece of the puzzle is to create the home page endpoint that can be accessed with 
the GitHub token and will recognize the user by resolving the token. We can define it in the 
main.py module:
from third_party_login import resolve_github_token
@router.get(
    "/home",
    responses=…, # add responses documentation
)
def homepage(
    user: UserCreateResponse = Depends(
        resolve_github_token
    ),
):
    return {
        "message" : f"logged in {user.username} !"
    }
You’ve just implemented 
Implementing MFA
99
Then, retrieve the token from the GitHub URL provided by the GET /auth/url endpoint.
You will use a token with your favorite tool to query the GET /home endpoint, which uses the 
GitHub token to validate permission.
At the time of writing, we cannot test endpoints requiring external bearer tokens with the interactive 
documentation, so feel free to use your favorite tool to query the endpoint by providing the bearer 
token in the headers authorization.
You can do it with Postman, for example, and you can use the equivalent curl request from your 
shell as well, as follows:
$ curl --location 'http://localhost:8000/home' \
--header 'Authorization: Bearer <github-token>'
If everything is correctly set up, you will receive the response:
{"message":"logged in <your-username> !"}
You just implemented and tested authentication by using a third-party application such as GitHub. 
Other providers such as Google or Twitter follow similar procedures, with small differences. Fee
Authentication and Authorization
100
Getting ready
For our FastAPI application, we’ll use a time-based one-time password (TOTP) as our MFA method. 
TOTP provides a six to eight-digit number that’s valid for a short period, typically 30 seconds.
First, ensure you have the necessary packages installed:
$ pip install pyotp
Pyotp is a Python library that implements one-time password algorithms, including TOTP.
To use the TOTP authentication, we need to modify the user table in our database to take into account 
the TOTP secret used to validate the secret number.
Let’s modify the User class in the models.py module by adding the totp_secret field:
class User(Base):
    # existing fields
    totp_secret: Mapped[str] = mapped_column(
        nullable=True
    )
We are now ready to implement MFA.
How to do it...
Let’s start by creating two helper functions to generate a TOTP secret and TOTP URI used by the 
authenticatorthrough the following steps.
1.	
We define the functions in a new module ca
Implementing MFA
101
We will use the generate_totp_secret and generate_totp_uri functions to create 
the endpoint to request MFA.
2.	
The endpoint will return a TOTP URI for use by the authenticator. To show the mechanism, 
we will also return the secret number, which in a real-life scenario is the number generated 
by the authenticator:
from fastapi import (
    APIRouter,
    Depends,
    HTTPException,
    status,
)
from sqlalchemy.orm import Session
from db_connection import get_session
from operations import get_user
from rbac import get_current_user
from responses import UserCreateResponse
router = APIRouter()
@router.post("/user/enable-mfa")
def enable_mfa(
    user: UserCreateResponse = Depends(
        get_current_user
    ),
    db_session: Session = Depends(get_session),
):
    secret = generate_totp_secret()
    db_user = get_user(db_session, user.username)
    db_user.totp_secret = secret
    db_session.add(db_user)
    db_session.commit()
    totp_uri = generate_totp_uri(
Authentication and Authorization
102
        "totp_uri": totp_uri,
        "secret_numbers": pyotp.TOTP(secret).now(),
    }
3.	
Now, we can create the endpoint to validate the secret number:
@app.post("/verify-totp")
def verify_totp(
    code: str,
    username: str,
    session: Session = Depends(get_session),
):
    user = get_user(session, username)
    if not user.totp_secret:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="MFA not activated",
        )
    totp = pyotp.TOTP(user.totp_secret)
    if not totp.verify(code):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid TOTP token",
        )
    # Proceed with granting access
    # or performing the sensitive operation
    return {
        "message": "TOTP token verified successfully"
    }
As before, you need to include the router in the FastAPI object class in main.py for all the 
previous endpoints.
To test it, a
Handling API key authentication
103
Make sure you have a user in your database, go to the interactive documentation, and call the /user/
enable-mfa endpoint by authenticating with the user credentials. You will get a response with the 
TOTP URI and a temporary secret number, like the following:
{
  "totp_uri":
  "otpauth://totp/YourAppName:giunio%40example.com?secret=
  NBSUC4CFDUT5IEYX4IR7WKBTDTU7LN25&issuer=YourAppName",
  "secret_numbers": "853567"
}
Take note of the secret number to use as a parameter of the /verify-totp endpoint with the 
username, and you will get this response:
{
  "message": "TOTP token verified successfully"
}
You’ve just implemented MFA in your FastAPI application and enhanced security by ensuring that 
even if a user’s password is compromised, an attacker still needs access to the user’s second factor (the 
device running the MFA app) to gain access.
See also
Take a look at the Python One-Time Password library in the official documentation:
•	 Python One-Tim
Authentication and Authorization
104
Getting ready
We will keep working on our application. However, you can apply this recipe to a simple application 
from scratch as well.
How to do it...
Let’s create an api_key.py module to store the logic to handle API keys. The package will contain 
the API list and verification method:
from fastapi import HTTPException
from typing import Optional
VALID_API_KEYS = [
    "verysecureapikey",
    "anothersecureapi",
    "onemoresecureapi",
]
async def get_api_key(
    api_key: Optional[str]
):
    if (
        api_key not in VALID_API_KEYS
    ):
        raise HTTPException(
            status_code=403, detail="Invalid API Key"
        )
    return api_key
In the example, the keys are hardcoded into the VALID_API_KEYS list. However, in real-life 
production scenarios, the management and validation of the keys are usually done by dedicated 
libraries or even services.
Let’s create an endpoint that makes use of the API key:
from fastatpi import APIrout
Handling session cookies and logout functionality
105
    api_key: str = Depends(get_api_key),
):
    return {"message": "Access to secure data granted"}
Now, add the router to the FastAPI object class in main.py, and then the endpoint is ready to 
be tested.
Spin up the server from the command by running the following:
$ uvicorn main:app
Go to the interactive documentation at http://localhost:8000/docs and test the endpoint 
you just created by providing an API key.
As you see, by adding a simple dependency to the endpoint, you can secure any endpoint of your 
app with an API key.
There’s more…
We have developed a simple module for managing the API of our application. In production 
environment this can be handled by external services often provided by the hosting platform. However, 
If you are going to implement your API management system, keep in mind the best practices for API 
key authentication:
•	 Transmission security: Always use HTTPS to prevent API keys from being intercepted
Authentication and Authorization
106
Getting ready
Sessions provide a way to persist user data across requests. When a user logs in, the application creates 
a session on the server side and sends a session identifier to the client, usually in a cookie. The client 
sends this identifier back with each request, allowing the server to retrieve the user’s session data.
The recipe will show how to manage cookies for sessions with login and logout functionality.
How to do it...
Cookies in FastAPI are easily managed by the Request and Response object classes. Let’s create a 
login and a logout endpoints to attaches a session cookie to the response and ignore it from the request. 
Let’s create a dedicated module called user_session.py and add the /login endpoint:
from fastapi import APIRouter, Depends, Response
from sqlalchemy.orm import Session
from db_connection import get_session
from operations import get_user
from rbac import get_current_user
from responses import UserCreateResponse
rout
Handling session cookies and logout functionality
107
Spin up the server with uvicorn main:app and use Postman to create a Post request to the /
login endpoint by providing the authentication token for the user you want to log in.
Verify that the response contains the fakesession cookie by selecting Cookies from the drop-
down menu of the response section.
Accordingly, we can define a logout endpoint that won’t return any session cookie in the response:
@router.post("/logout")
async def logout(
    response: Response,
    user: UserCreateResponse = Depends(
         get_current_user
    ),
):
    response.delete_cookie(
        "fakesession"
    )  # Clear session data
    return {"message": "User logged out successfully"}
That’s all you need to manage sessions.
To test the POST /logout endpoint, restart the server with uvicorn. Then, when calling the 
endpoint, make sure you provide the fakesession cookie in your HTTP request with the user 
bearer token. If you previously called the l
Authentication and Authorization
108
By integrating session management and logout functionality into your FastAPI application, you ensure 
that user state is managed securely and efficiently across requests. This enhances both the security and 
user experience of your application. Remember to follow best practices for session security to protect 
your users and their data effectively.
In the next chapter, we will see how to efficiently debug your FastAPI application.
See also
You can see more on managing cookies in Fast on the documentation page:
•	 Response cookies: https://fastapi.tiangolo.com/advanced/response-
cookies/
5
Testing and Debugging 
FastAPI Applications
In this chapter of our journey through mastering FastAPI, we pivot towards a crucial aspect of software 
development that ensures the reliability, robustness, and quality of your applications: testing and 
debugging. As we delve into this chapter, you’ll be equipped with the knowledge and tools necessary 
to create an effective testing environment, write and execute comprehensive tests, and debug your 
FastAPI applications with efficiency and precision.
Understanding how to properly test and debug is not just about finding errors; it’s about ensuring your 
application can withstand real-world use, manage high traffic without faltering, and provide a seamless 
user experience. By mastering these skills, you’ll be able to confidently enhance your applications, 
knowing that each line of code has been scrutinized and each potential bottleneck has been addressed.
We are going to create a proto application with a minimal setup to test the recipe
Testing and Debugging FastAPI Applications
110
Technical requirements
To dive into the chapter and follow along with the recipes, ensure your setup includes the 
following essentials:
•	 Python: Make sure to have a Python version 3.7 or higher installed on your computer.
•	 FastAPI: Have fastapi package in your working environment.
•	 Pytest: Be familiar with pytest framework, which is a testing framework largely used to 
test Python code.
The code used in the chapter is hosted on GitHub at the address: https://github.com/
PacktPublishing/FastAPI-Cookbook/tree/main/Chapter05.
You can setup a virtual environment for the project within the project root folder is also recommended 
to manage dependencies efficiently and maintain project isolation. Within your virtual environment, 
you can install all the dependencies at once by using the requirements.txt provided on the 
GitHub repository in the project folder:
$ pip install –r requirements.txt
A basic knowledge of HTTP protocol, although 
Setting up testing environments
111
@app.get("/home")
async def read_main():
    return {"message": "Hello World"}
With a minimal app setup, we can proceed by scaffolding our project to accommodate the tests.
How to do it...
First, let’s start by structuring our project folder tree to accommodate tests.
1.	
In the root directory let’s create a pytest.ini file and a tests folder containing the test 
module test_main.py. The project structure should look like this:
protoapp/
|─ protoapp/
│  |─ main.py
|─ tests/
│  |─ test_main.py
|─ pytest.ini
2.	
The pytest.ini contains instructions for pytest. You can write in it:
[pytest]
pythonpath = . protoapp
This will add the project root and the folder protoapp, containing the code, to the PYTHONPATH 
when running pytest.
3.	
Now, in the test_main.py module, let’s write a test for the /home endpoint we created earlier:
import pytest
from httpx import ASGITransport, AsyncClient
from protoapp.main import app
@pytest.mark.asyncio
async def test_read
Testing and Debugging FastAPI Applications
112
        "message": "Hello World"
    }
As a first check of the environment, we can try to collect the tests. From the protoapp root 
project folder run:
$ pytest –-collect-only
You should get an output like:
configfile: pytest.ini
plugins: anyio-4.2.0, asyncio-0.23.5, cov-4.1.0
asyncio: mode=Mode.STRICT
collected 1 item
<Dir protoapp>
  <Dir tests>
    <Module test_main.py>
      <Coroutine test_read_main>
This specifies:
	 The configuration file pytest.ini
	 The pytest plugins used
	 The directory tests, the module test_main.py and the test test_read_main which 
is a coroutine
4.	
Now, from the command line terminal at the project root folder level, run the pytest command:
$ pytest
You’ve just setup the environment to test our proto application.
See also
The recipe has shown how to configure pytest within a FastAPI project with some of the good 
practices. Feel free to dig deeper into the Pytest official documentation at the links:
•	 
Writing and running unit tests
113
Writing and running unit tests
Once we setup our testing environment, we can focus on the process of writing and executing tests 
for FastAPI applications. Unit tests are essential for validating the behaviour of individual parts of 
your application in isolation, ensuring they perform as expected. In this recipe, you will learn to test 
the endpoints of your application.
Getting ready
We will use pytest to test the FastAPI client in unit tests. Since the recipe will utilize common testing 
fixtures, used in most Python standard code, make sure to be familiar with the test fixtures before 
diving into the recipe. If this is not the case, you can always refer to the dedicated documentation 
page at the link: https://docs.pytest.org/en/7.1.x/reference/fixtures.html.
How to do it…
We will start by creating a unit test for the same GET /home endpoint, but differently from the 
previous recipe. We will use the TestClient class provided by FastAPI.
Let’s cr
Testing and Debugging FastAPI Applications
114
And that’s it. Compared to the previous test, this one is more compact and faster to write, thanks to 
the TestClient class provided by FastAPI package.
Now run pytest:
$ pytest
You will see a message on the terminal showing that two tests have been collected and run successfully.
See also
You can check more on the test client for FastAPI in the official documentation:
•	 FastAPI Test Client: https://fastapi.tiangolo.com/reference/testclient/
Testing API Endpoints
Integration tests verify that different parts of your application work together as expected. They are 
crucial for ensuring that your system’s components interact correctly, especially when dealing with 
external services, databases, or other APIs.
In this recipe, we will test two endpoints that interact with an SQL database. One will add an item to 
the database, the other will read an item based on the ID.
Getting ready
To apply the recipe you need your testing environment alre
Testing API Endpoints
115
Now let’s setup the database connection through the following steps.
1.	
Under the protoapp folder, at the same level as the main.py module, let’s create a module 
database.py containing the setup of the database. Let’s start by creating the Base class:
from sqlalchemy.orm import DeclarativeBase,
class Base(DeclarativeBase):
    pass
We will use the Base class to define the Item mapping class.
2.	
Then the database Item mapping class will be like:
from sqlalchemy.orm import (
    Mapped,
    mapped_column,
)
class Item(Base):
    __tablename__ = "items"
    id: Mapped[int] = mapped_column(
        primary_key=True, index=True
    )
    name: Mapped[str] = mapped_column(index=True)
    color: Mapped[str]
3.	
Then, we define the database engine that will handle the session:
DATABASE_URL = "sqlite:///./production.db"
engine = create_engine(DATABASE_URL)
The engine object will be used to handle the session.
4.	
Then, let’s bind the engine to the Base mapping class
Testing and Debugging FastAPI Applications
116
5.	
Last in the database.py module let’s create a SessionLocal class that will generate 
the session as:
SessionLocal = sessionmaker(
    autocommit=False, autoflush=False, bind=engine
)
The SessionLocal is a class that will initialize the database session object.
6.	
Finally, before creating the endpoints, let’s create a database session.
Since the app is relatively small, we can do it the same main.py:
from protoapp.database import SessionLocal
def get_db_session():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
We will use the session to interact with the database.
Now that we have setup the database connection, in the main.py module, we can create the endpoints 
one to add an item to the database and one to read it. Let's do it as follows.
1.	
Let's start by creating the request body for the endpoints as::
from pydantic import BaseModel
class ItemSchema(BaseModel):
    name: str
    color: str
2.	
The
Testing API Endpoints
117
@app.post(
"/item",
response_model=int,
status_code=status.HTTP_201_CREATED
)
def add_item(
    item: ItemSchema,
    db_session: Session = Depends(get_db_session),
):
    db_item = Item(name=item.name, color=item.color)
    db_session.add(db_item)
    db_session.commit()
    db_session.refresh(db_item)
    return db_item.id
The endpoint will return the item ID affected when the item is stored in the database. 
3.	
Now that we have the endpoint to add the item, we can proceed by creating the endpoint to 
retrieve the item based on its ID:
@app.get("/item/{item_id}", response_model=ItemSchema)
def get_item(
    item_id: int,
    db_session: Session = Depends(get_db_session),
):
    item_db = (
        db_session.query(Item)
        .filter(Item.id == item_id)
        .first()
    )
    if item_db is None:
        raise HTTPException(
            status_code=404, detail="Item not found"
        )
    return item_db
If the ID does not correspond to any item in th
Testing and Debugging FastAPI Applications
118
How to do it…
Once we have the endpoints, in the tests folder we should adapt our test_client fixture to 
use a different session than the one used in production.
We will break the process into two main actions:
•	 Adapt the test client to accommodate the testing database session
•	 Create the test to simulate the interaction of the endpoints
Let's do it by following these steps.
1.	
First, In the conftest.py file we created earlier in the recipe Writing and running unit 
tests, let’s define a new engine that will use an in-memory SQLite database and bind it to the 
mapping Base class:
from sqlalchemy.pool import StaticPool
from sqlalchemy import create_engine
engine = create_engine(
    "sqlite:///:memory:",
    connect_args={"check_same_thread": False},
    poolclass=StaticPool,
)
Base.metadata.create_all(bind=engine)  # Bind the engine
2.	
Let’s create a dedicated session maker for the testing session as:
from sqlalchemy.orm import sess
Testing API Endpoints
119
    finally:
        db.close()
4.	
Then, we should modify the test_client to use this session instead of the production 
one. We can do it by overwriting the dependency that returns the session with the one we just 
created. FastAPI allows you to do it easily by calling the test client’s method dependency_
overrides as:
from protoapp.main import app, get_db_session
@pytest.fixture(scope="function")
def test_client(test_db_session):
    client = TestClient(app)
    app.dependency_overrides[get_db_session] = (
        lambda: test_db_session
    )
    return client
Each time the test client needs to call the session, the fixture will replace it with the test session 
that uses the in-memory database.
5.	
Then, to verify the interaction of our application with the database, we create a test that:
	 Create the item into the database through the POST /item endpoint
	 Verify that the item is correctly created into the test database by using the test session
	 Re
Testing and Debugging FastAPI Applications
120
        .filter(Item.id == item_id)
        .first()
    )
    assert item is not None
    response = test_client.get(f"item/{item_id}")
    assert response.status_code == 200
    assert response.json() == {
        "name": "ball",
        "color": "red",
    }
You’ve just created an integration test for our proto application, feel free to enrich your application 
and create more tests accordingly.
See also
We have setup an in-memory SQLite database for our tests. Since each session is bonded to a thread, 
the engine needs to be configured accordingly to not flush data.
The configuration strategy has been found on the following documentation page:
•	 SQLite In-Memory Database Configuration: https://docs.sqlalchemy.org/en/14/
dialects/sqlite.html#using-a-memory-database-in-multiple-threads
Running tests techniques
By systematically covering all endpoints and scenarios, you ensure that your API behaves correctly 
under various conditions, pr
Running tests techniques
121
As you already know, all unit tests can be run from the terminal with the command:
$ pytest
However, a test can be run individually according to the test call syntax:
$ pytest <test_module>.py::<test_name>
For example, if we want to run the test function test_read_main_client, run:
$ pytest tests/test_main.py::test_read_main
Sometimes test names become too complicated to remember or we have a specific need to run only 
a targeted set of tests. Here is where test marks come to the aid.
Let’s imagine we want to run only integration tests. In our app, the only integration test is represented 
by the function tests_client_can_add_read_the_item_from_database.
We can apply a mark by adding the specific decorator to the function:
@pytest.mark.integration
def test_client_can_add_read_the_item_from_database(
    test_client, test_db_session
):
    # test content
Then, in the pytest.ini configuration add the integration marker in the dedicated sections 
to register t
Testing and Debugging FastAPI Applications
122
Check test coverage
To make sure that your endpoints are covered by testing as well as the text lines of your code, it can 
become useful to have an idea of the test coverage.
Test coverage is a metric used in software testing to measure the extent to which the source code of 
a program is executed when a particular test suite runs.
To use it with pytest, if you didn’t install the packages with the requirements.txt, you need 
to install pytest-cov package:
$ pip install pytest-cov
The way it works is quite straightforward. You need to pass the source code root, in our case the 
protoapp directory, to the parameter –cov of pytest and tests root folder, in our case tests 
as follows:
$ pytest –-cov protoapp tests
You will see a table in the output listing the coverage percentage for each module:
Name                   Stmts   Miss  Cover
------------------------------------------
protoapp\database.py      16      0   100%
protoapp\main.py   
Handling logging messages
123
Handling logging messages
Effectively managing logs in application development not only aids in identifying errors promptly 
but also provides valuable insights into user interactions, system performance, and potential security 
threats. It serves as a crucial tool for auditing, compliance, and optimizing resource utilization, 
ultimately enhancing the reliability and scalability of the software.
This recipe will show how to efficiently implement a logging system into our FastAPI application to 
monitor the calls to the API.
Getting ready
We are going to use some basic features of the Python logging ecosystem.
Although the example is basic, you can refer to the official documentation to get familiar with related 
terms such as logger, handler , formatter, and log level. Follow this link:
https://docs.python.org/3/howto/logging-cookbook.html.
To implement logging into FastAPI, make sure you have a running application or use the protoapp 
we developed all al
Testing and Debugging FastAPI Applications
124
This will stream the message to the console.
3.	
Let’s create a colorized formatter and add it to the handler we just created:
from uvicorn.logging import ColourizedFormatter
console_formatter = ColourizedFormatter(
    "%(levelprefix)s CLIENT CALL - %(message)s",
    use_colors=True,
)
console_handler.setFormatter(console_formatter)
The formatter will format log messages in the same of the default logger uvicorn logger used 
by FastAPI.
4.	
Then let’s add the handler to the logger:
client_logger.addHandler(console_handler)
We have just set up the logger to print message to the console.
5.	
Let’s repeat the previous steps from 1 to 4 to create a handler that stores messages into a file and 
adds it to our client_logger:
from logging.handlers import TimedRotatingFileHandler
file_handler = TimedRotatingFileHandler("app.log")
file_formatter = logging.Formatter(
    "time %(asctime)s, %(levelname)s: %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S
Handling logging messages
125
You can reach this by adding the logger and a dedicated middleware in the main.py module:
from protoapp.logging import client_logger
# ... module content
@app.middleware("http")
async def log_requests(request: Request, call_next):
    client_logger.info(
        f"method: {request.method}, "
        f"call: {request.url.path}, "
        f"ip: {request.client.host}"
    )
    response = await call_next(request)
    return response
7.	
Now spin up the server:
$ uvicorn protoapp.main:app
Try to call any of the endpoints we defined, you will see on the terminal the logs we just defined for 
the request and response. Also, you will find only the messages from our logger_client in a 
newly created app.log file automatically created by the application.
There’s more
Defining a proper logging strategy would require a separate cookbook and it is out of the scope of the 
book. However, when building a logger into an application it is important to follow some guidelin
Testing and Debugging FastAPI Applications
126
See also
Python distribution comes with a powerful built-in package for logging, feel to have a look at the 
official documentation:
•	 Python logging: https://docs.python.org/3/library/logging.html
Furthermore, discover more on logging best practices and guidelines at the Sentry blog:
•	 Logging Guidelines: https://blog.sentry.io/logging-in-python-a-
developers-guide/
Sentry is a tool to monitor Python code.
Debugging techniques
Mastering debugging application development is crucial for identifying and fixing issues efficiently. 
This recipe delves into the practical use of the debugger, leveraging tools and strategies to pinpoint 
problems in your FastAPI code.
Getting ready
All you need to do to apply the recipe is to have a running application. We can keep on working with 
our protoapp.
How to do it...
The Python distribution already comes with a default debugger called pdb. If you use an integrated 
development environment (IDE), it u
Debugging techniques
127
The script imports the uvicorn package and our application app and runs the application into the 
uvicorn server. It is equivalent to the launching command:
$ uvicorn protoapp.main:app
Having a script gives us more flexibility to run the server and include it into a broader python routine 
if required.
To check that it is correctly setup run the script as you would run a normal python script:
$ python run_server.py
With your favourite browser go to localhost:8000/docs and check that the documentation 
has been correctly generated.
Debugging with PDB
The PDB debugger comes by default with any Python distribution. From Python versions higher than 
3.7, you can define a breakpoint by simply adding the function call breakpoint() at the line of 
the code you want to pause, and then run the code as you would it normally.
If you then run the code, when it reaches the breakpoint line, the execution will automatically shift to 
debug mode, and you can run debugging comm
Testing and Debugging FastAPI Applications
128
Another debugging strategy consists of leveraging the reload functionality of the uvicorn server. 
To do that, you need to modify the run_server.py file as:
import uvicorn
if __name__ == "__main__":
    uvicorn.run("protoapp.main:app", reload=True)
Then, run the server without the pdb module:
$ python run_server.py
In this way, you can always use the breakpoints at ease with the reloading server functionality.
At the time of writing, post-mortem debugging is not supported with the automatic reload of unvicorn.
Debugging with VS Code
VS Code Python extension comes with its distribution debugger called debugpy. Configurations for 
the running environment can be managed in the .vscode/launch.json file. An example of the 
configuration file to debug our server is:
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Python Debugger FastAPI server",
            "type": "debugpy",
            "request": "launch",
    
Debugging techniques
129
Debugging configuration can be setup to run unit tests as well by leveraging the Test Explorer extension. 
The extension will look for a configuration in the launch.json containing "type": "python" 
and "purpose": ["debug-test"] (or "request": "test"). An example of configuration 
to debug tests would be:
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Debug test",
            "type": "python",
            "request": "launch",
            "console": "integratedTerminal",
            "justMyCode": false,
            "stopOnEntry": true,
            "envFile": "${workspaceFolder}/.env.test",
            "purpose": ["debug-test"]
        }
    ]
}
You can find an extensive explication on the extension page from the VS Code marketplace at: 
https://marketplace.visualstudio.com/items?itemName=LittleFoxTeam.
vscode-python-test-adapter.
Debugging with PyCharm
PyCharm manages code execution through run/debug configurations, which are se
Testing and Debugging FastAPI Applications
130
An example of configuration for our FastAPI protoapp is the following:
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="run_server"
    type="PythonConfigurationType" factoryName="Python"
    nameIsGenerated="true">
    <module name="protoapp" />
    <option name="INTERPRETER_OPTIONS" value="" />
    <option name="PARENT_ENVS" value="true" />
    <envs>
      <env name="PYTHONUNBUFFERED" value="1" />
    </envs>
    <option name="WORKING_DIRECTORY"
      value="$PROJECT_DIR$" />
    <option name="IS_MODULE_SDK" value="true" />
    <option name="ADD_CONTENT_ROOTS" value="true" />
    <option name="ADD_SOURCE_ROOTS" value="true" />
    <option name="SCRIPT_NAME"
      value="$PROJECT_DIR$/run_server.py" />
    <option name="SHOW_COMMAND_LINE" value="false" />
    <option name="MODULE_MODE" value="false" />
    <option name="REDIRECT_INPUT" value="false" />
    <option name="INPUT_FILE" value="" />
    
Performance testing for high traffic applications
131
•	 Debugy Debugger: https://github.com/microsoft/debugpy/
•	 Debugging with PyCharm: https://www.jetbrains.com/help/pycharm/debugging-
your-first-python-application.html
Performance testing for high traffic applications
Performance testing is crucial for ensuring your application can handle real-world usage scenarios, 
especially under high load. By systematically implementing and running performance tests, analyzing 
results, and optimizing based on findings, you can significantly improve your application’s responsiveness, 
stability, and scalability.
The recipe will show the basics of how to benchmark your application with Locust framework.
Getting ready
To run performance testing you need a working application, we will use our protoapp, and a 
testing framework. We will use Locust framework for the purpose, which a testing framework based 
on Python syntax.
You can find a detailed explication on the official documentation at: htt
Testing and Debugging FastAPI Applications
132
    def hello_world(self):
        self.client.get("/home")
The configuration defines a client class with the service address and the endpoint we want to test.
Start your FastAPI server with:
$ uvicorn protoapp.main:app
Then in another terminal window run locust:
$ locust
Open your browser and navigate to http://localhost:8089 to access the web interface of 
the application.
The web interface is intuitively designed, making it straightforward to:
•	 Set Concurrent Users: Specify the maximum number of users accessing the service simultaneously 
during peak usage.
•	 Configure Ramp-Up Rate: Determine the rate of new users added per second to simulate 
increasing traffic.
After configuring these parameters, click the Start button to initiate a simulation that generates traffic 
to the protoapp via the /home endpoint defined in the locustfile.py.
Alternatively, you can simulate traffic using the command line. Here’s how:
$ locust --headless --
Performance testing for high traffic applications
133
See also
You can find more on Locust on the official documentation pages:
•	 Locust QuickStart: https://docs.locust.io/en/stable/quickstart.html
•	 Writing a Locust file: https://docs.locust.io/en/stable/writing-a-
locustfile.html
•	 Running Locust from the Command Line: https://docs.locust.io/en/stable/
running-without-web-ui.html

6
Integrating FastAPI 
with SQL Databases
We’ll now embark on a journey to harness the full potential of SQL databases within your FastAPI 
applications. This chapter is meticulously designed to guide you through the nuances of leveraging 
SQLAlchemy, a powerful SQL toolkit and object-relational mapping (ORM) for Python. From 
setting up your database environment to implementing sophisticated create, read, update and delete 
(CRUD) operations and managing complex relationships, this chapter provides a comprehensive 
blueprint for integrating SQL databases seamlessly with FastAPI.
By creating a basic ticketing platform, you’ll practically engage in configuring SQLAlchemy with 
FastAPI, creating data models that reflect your application’s data structures, and crafting efficient, 
secure CRUD operations.
Moreover, you’ll explore the management of database migrations with Alembic, ensuring your database 
schema evolves alongside your application without hassle. This chapter doesn’t stop at
Integrating FastAPI with SQL Databases
136
•	 Optimizing SQL queries for performance
•	 Securing sensitive data in SQL databases
•	 Handling transactions and concurrency
Technical requirements
To follow along with all the recipes of the chapter, make sure you have these essentials in your setup:
•	 Python: Your environment should have a Python version above 3.9 installed.
•	 FastAPI: It should be installed in your virtual environment with all the dependencies it needs. 
If you didn’t do it in the previous chapters, you can easily do it from your terminal:
$ pip install fastapi[all]
The code that accompanies the chapter is available on GitHub at the following link: https://
github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter06
It is also advisable to create a virtual environment for the project inside the project root folder, to 
handle dependencies well and keep the project separate. In your virtual environment, you can install 
all the dependencies at once by using the requi
Setting up SQLAlchemy
137
You need fastapi, sqlalchemy, and aiosqlite installed in your environment to use the 
recipe. The recipe is meant to work with sqlalchemy with versions above 2.0.0. You can still use 
version 1; however, some adaptions are required. You can find a migration guide at the following 
link: https://docs.sqlalchemy.org/en/20/changelog/migration_20.html.
If you haven’t installed the packages with the requirements.txt file in the repo, you can do it 
by running the following:
$ pip install fastapi[all] "sqlalchemy>=2.0.0" aiosqlite
Once the packages are correctly installed, you can follow the recipe.
How to do it...
The setup of a generic SQL database connection with sqlalchemy will go through the following steps:
1.	
Creating mapping object classes, that will match the database tables
2.	
Creating abstraction layers, an engine, and a session to communicate with the database
3.	
Initializing a database connection, at the server startup
Creating mapping object classes
Integrating FastAPI with SQL Databases
138
We just created a Ticket class that will be used to match the tickets table into our SQL database.
Creating abstraction layers
In SQLAlchemy, the engine manages database connections and executes SQL statements, while a 
session allows querying, inserting, updating, and deleting data within a transactional context, ensuring 
consistency and atomicity. Sessions are bound to an engine for communication with the database.
We will start by creating a function that returns the engine. In a new module called db_connection.py, 
under the app folder, let’s write the function as follows:
from sqlalchemy.ext.asyncio import (
    create_async_engine,
)
from sqlalchemy.orm import sessionmaker
SQLALCHEMY_DATABASE_URL = (
    "sqlite+aiosqlite:///.database.db"
)
def get_engine():
    return create_async_engine(
        SQLALCHEMY_DATABASE_URL, echo=True
    )
You may have observed that the SQLALCHEMY_DATABASE_URL database URL uses the sqlite 
and aiosqlite m
Setting up SQLAlchemy
139
async def get_db_session():
    async with AsyncSessionLocal() as session:
        yield session
The get_db_session function will be used as a dependency for each endpoint interacting with 
the database.
Initializing a database connection
Once we have the abstraction layers, we need to create our FastAPI server object and start the database 
classes when the server runs. We can do it in the main.py module under the app folder:
from contextlib import asynccontextmanager
from fastapi import FastAPI
from app.database import Base
from app.db_connection import (
    AsynSessionLocal,
    get_db_session
)
@asynccontextmanager
async def lifespan(app: FastAPI):
    engine = get_engine()
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
        yield
    await engine.dispose()ispose()
app = FastAPI(lifespan=lifespan)
To specify server actions at the startup event, we have used the lifespan parameter.
We have everything in plac
Integrating FastAPI with SQL Databases
140
To check that our app communicates with our database, let’s spin up the server from the command 
line at the project root folder:
$ uvicorn app.main:app
You should see message logs on the command output that says table tickets have been created. 
Furthermore, open the .database.db file with the database reader you prefer, and the table should 
be there with the schema that is defined in the database.py module.
See also
You can see more about how to set up a database with SQLAlchemy and how to make it compatible 
with the asyncio module on the official documentation pages:
•	 How to set up an SQLAlchemy database: https://docs.sqlalchemy.org/en/20/
orm/quickstart.html
•	 SQLAlchemy asyncio extension reference: https://docs.sqlalchemy.org/en/20/
orm/extensions/asyncio.html
In this example, we have used an SQLite database by specifying the following:
SQLALCHEMY_DATABASE_URL = "sqlite+aiosqlite:///.database.db"
However, you can use SQLAlchemy to in
Implementing CRUD operations
141
Implementing CRUD operations
CRUD operations with a RESTful API can be implemented using HTTP methods (POST, GET, PUT, 
and DELETE) for web services. This recipe demonstrates how to use SQLAlchemy and asyncio 
to build CRUD operations asynchronously on an SQL database with the corresponding endpoints.
Getting ready
Before you start with the recipe, you need to have a database connection and a table in the dataset, 
as well as a matching class in the code base. If you completed the previous recipe, you should have 
them ready.
How to do it…
We’ll begin by making an operations.py module under the app folder to contain our database 
operations by following these steps.
1.	
First, we can set up the operation to add a new ticket to the database as follows:
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from app.database import Ticket
async def create_ticket(
    db_session: AsyncSession,
    show_name: str,
    user: str
Integrating FastAPI with SQL Databases
142
The function will give back the ID attached to the ticket when saved.
2.	
Then, let’s create a function to get a ticket:
async def get_ticket(
    db_session: AsyncSession, ticket_id: int
) -> Ticket | None:
    query = (
        select(Ticket)
        .where(Ticket.id == ticket_id)
    )
    async with db_session as session:
        tickets = await session.execute(query)
        return tickets.scalars().first()
If the ticket is not found, the function will return a None object.
3.	
Then, we build an operation to update only the price of the ticket:
async def update_ticket_price(
    db_session: AsyncSession,
    ticket_id: int,
    new_price: float,
) -> bool:
    query = (
        update(Ticket)
        .where(Ticket.id == ticket_id)
        .values(price=new_price)
    )
    async with db_session as session:
        ticket_updated = await session.execute(query)
        await session.commit()
        if ticket_updated.rowcount == 0:
        
Implementing CRUD operations
143
            delete(
                Ticket
            ).where(Ticket.id == ticket_id)
        )
        await session.commit()
        if tickets_removed.rowcount == 0:
            return False
        return True
Similarly to the update operation, the function returns False if it does not find any ticket 
to delete.
5.	
After defining the operations, we can expose them by creating the corresponding endpoints 
in the main.py module.
Let’s do it for the create operation right after defining the app server:
from typing import Annotated
from sqlalchemy.ext.asyncio import AsyncSession
from app.db_connection import (
    AsyncSessionLocal,
    get_engine,
    get_session
)
from app.operations import create_ticket
# rest of the code 
class TicketRequest(BaseModel):
    price: float | None
    show: str | None
    user: str | None = None
@app.post("/ticket", response_model=dict[str, int])
async def create_ticket_route(
    ticket: TicketRequest,
    db_sessio
Integrating FastAPI with SQL Databases
144
        db_session,
        ticket.show,
        ticket.user,
        ticket.price,
    )
    return {"ticket_id": ticket_id}
The remaining operations can be exposed in the same way.
Exercise
Similarly to what we did for the create_ticket operation, expose the other operations 
(get, update, and delete) with the respective endpoints.
How it works…
The functions created to interact with the database are exposed through the endpoints. This means 
that an external user will execute the operations by calling the respective endpoints.
Let’s verify that the endpoint works correctly.
Start the server from the command line as usual by running the following:
$ uvicorn app.main:app
Then, go to the interactive documentation link at http://localhost:8000/docs, and you 
will see the endpoints you just created. Experiment with them in different combinations and see the 
results in the .database.db database file.
You have just created CRUD operations to inte
Working with migrations
145
The recipe shows you how to use Alembic, a popular tool for managing database migrations in 
Python. You will learn how to create, run, and roll back migrations and how to integrate them with 
your ticketing system.
Getting ready
To use the recipe, you need to have alembic in your environment. You can install it with pip, if 
you didn’t do it with the requirements.txt file from the GitHub repository, by typing this on 
the command line:
$ pip install alembic
You also need to make sure you have at least one class that corresponds to the table in the database you 
want to create. If you don’t have one, go back to the Setting up SQLAlchemy recipe and make one. If 
you’re already running the application, delete the .database.db file that the application has created.
How to do it…
To configure Alembic and manage database migrations, go through the following steps.
1.	
The first step is to set up alembic. In the project root folder, run the following command in 
t
Integrating FastAPI with SQL Databases
146
We can now create our first database migration script and apply the migration.
4.	
Execute the following command from the command line to create an initial migration:
$ alembic revision --autogenerate -m "Start database"
This will create a migration script automatically placed in the alembic/versions folder.
5.	
Make sure you removed the existing .database.db file, and let’s execute our first migration 
with the following command:
$ alembic upgrade head
This will automatically rebuild the .database.db file with the tickets table in it.
How it works…
Once we have the first version of our database, let’s see the migration in action.
Imagine we want to change the table in the database.py module while the application is already 
deployed in a production environment so that we can’t delete any records when updating it.
Add some tickets to the database, then in the code, let’s add a new field called sold that will indicate 
if the ticket has been so
Handling relationships in SQL databases
147
See also
You can see more on how to manage database migrations with Alembic at the official documentation links:
•	 Setting up Alembic: https://alembic.sqlalchemy.org/en/latest/tutorial.
html
•	 Autogenerating migrations: https://alembic.sqlalchemy.org/en/latest/
autogenerate.html
Handling relationships in SQL databases
Database relationships are associations between two or more tables that allow you to model complex 
data structures and perform queries across multiple tables. In this recipe, you will learn how to 
implement one-to-one, many-to-one, and many-to-many relationships for the existing ticketing system 
application. You will also see how to use SQLAlchemy to define your database schema relationships 
and query the database.
Getting ready
To follow the recipe, you need to have the core of the application already implemented with at least 
one table in it. If you have already done that, you will also have the necessary packages ready
Integrating FastAPI with SQL Databases
148
    price: Mapped[float] = mapped_column(
        nullable=True
    )
    show: Mapped[str | None]
    user: Mapped[str | None]
    sold: Mapped[bool] = mapped_column(default=False)
    details: Mapped["TicketDetails"] = relationship(
        back_populates="ticket"
    )
2.	
Then, we create the table to map the ticket’s details as follows:
from sqlalchemy import ForeignKey
class TicketDetails(Base):
    __tablename__ = "ticket_details"
    id: Mapped[int] = mapped_column(primary_key=True)
    ticket_id: Mapped[int] = mapped_column(
        ForeignKey("tickets.id")
    )
    ticket: Mapped["Ticket"] = relationship(
        back_populates="details"
    )
    seat: Mapped[str | None]
    ticket_type: Mapped[str | None]
Once the database classes are set up to accommodate the new table, we can proceed to update the 
CRUD operations with the following steps.
1.	
To update ticket details, let’s create a dedicated function in the operations.py module
Handling relationships in SQL databases
149
             *updating_ticket_details
        )
        result = await db_session.execute(
                ticket_query
            )
        await db_session.commit()
        if result.rowcount == 0:
                return False
    return True
The function will return False if no records have been updated.
2.	
Next, modify the create_ticket function to consider the details of the ticket and create 
an endpoint to expose the updating operation we just created, like so:
async def create_ticket(
    db_session: AsyncSession,
    show_name: str,
    user: str = None,
    price: float = None,
) -> int:
    ticket = Ticket(
        show=show_name,
        user=user,
        price=price,
        details=TicketDetails(),
    )
    async with db_session.begin():
        db_session.add(ticket)
        await db_session.flush()
        ticket_id = ticket.id
        await db_session.commit()
    return ticket_id
In this example, each time a ticket is cr
Integrating FastAPI with SQL Databases
150
Many to one
A ticket can be associated with an event, and an event can have multiple tickets. To showcase a 
many-to-one relationship, we will create an events table that will have a relationship with the 
tickets table. Let’s go through the following steps:
Let’s first create a column in the tickets table that will accommodate the reference to the events 
table in the database.py module, as follows:
class Ticket(Base):
    __tablename__ = "tickets"
    # skip existing columns
    event_id: Mapped[int | None] = mapped_column(
        ForeignKey("events.id")
    )
    event: Mapped["Event | None"] = relationship(
        back_populates="tickets"
    )
Then, we create an Event class to map the events table into the database:
class Event(Base):
    __tablename__ = "events"
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str]
    tickets: Mapped[list["Ticket"]] = relationship(
        back_populates="event"
    )
ForeignKey,
Handling relationships in SQL databases
151
To work with many-to-many relationships, we need to define a class for the concerned tables and 
another class to track the so-called association table.
Let’s start by defining a column to accommodate relationships in the Event class:
class Event(Base):
    __tablename__ = "events"
    # existing columns
    sponsors: Mapped[list["Sponsor"]] = relationship(
        secondary="sponsorships",
        back_populates="events",
    )
Then, we can create a class to map the sponsors table:
class Sponsor(Base):
    __tablename__ = "sponsors"
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(unique=True)
    events: Mapped[list["Event"]] = relationship(
        secondary="sponsorships",
        back_populates="sponsors",
    )
As you might have noticed, the class contains columns to accommodate the events reference.
Finally, we can define an association table that will be the sponsorships table:
class Sponsors
Integrating FastAPI with SQL Databases
152
The association table can contain information on the relationship itself. For example, in our case, a 
piece of useful information is the amount provided by the sponsor for the event.
This is all you need to create many-to-many relationships for your ticketing system platform.
Exercise
To complete your application, create an operations function with the relative endpoints to do 
the following:
- Add a sponsor to the database.
- Add a sponsorship with the amount. If the sponsorship already exists, replace the sponsorship 
with the new amount.
See also
You can dive deeper into handling relationships with SQLAlchemy at the following official 
documentation page:
•	 SQLAlchemy basic relationships: https://docs.sqlalchemy.org/en/20/orm/
basic_relationships.html
Optimizing SQL queries for performance
Optimizing SQL queries is key in database management, as it enhances efficiency, scalability, cost-
effectiveness, user satisfaction, data integrity, 
Optimizing SQL queries for performance
153
How to do it…
Improving SQL queries is a process that involves several steps. As with most optimization processes, 
many steps are specific to the use case, but there are general rules that can help optimize SQL queries 
overall, such as the following:
•	 Avoid N+1 queries
•	 Use the JOIN statement sparingly
•	 Minimize data to fetch
We will apply each with a significant example.
Avoiding N+1 queries
The N+1 query issue happens when your application does one query to get a list of items and then 
loops over those items to get related data, making N more queries.
Let’s say we want an endpoint to show all events with the associated sponsors. A first try might be to 
fetch the events table and loop over the events to fetch the sponsors table. This solution means 
a first query to get the events and N more queries to get the sponsors for each event, which is exactly 
what we want to avoid.
The solution is to load all related records in the query t
Integrating FastAPI with SQL Databases
154
The joinedload method will include a JOIN operation on the query, so it is no longer necessary 
to make N queries to get the sponsors.
Using the join statement sparingly
Joined tables can make the query easier to read. But be careful and only join tables that you need for 
your query.
Suppose we want to get a list of sponsors names with the amount given for a certain event in order 
from the highest to the lowest.
We can use multiple joins since we need to fetch three tables. The function would look like this:
async def get_event_sponsorships_with_amount(
    db_session: AsyncSession, event_id: int
):
    query = (
        select(Sponsor.name, Sponsorship.amount)
        .join(
            Sponsorship,
            Sponsorship.sponsor_id == Sponsor.id,
        )
        .join(
            Event,
            Sponsorship.event_id == Event.id
        )
        .order_by(Sponsorship.amount.desc())
    )
    async with db_session as session:
       
Optimizing SQL queries for performance
155
        )
        .where(Sponsorship.event_id == event_id)
        .order_by(Sponsorship.amount.desc())
    )
    async with db_session as session:
        result = await session.execute(query)
        sponsor_contributions = result.fetchall()
    return sponsor_contributions
This will return what we need without selecting the events table at all.
Minimizing data to fetch
Fetching more data than needed can slow down your queries and the application.
Use SQLAlchemy’s load_only function to load only specific columns from the database.
Imagine that for a marketing analysis, we are asked to make a function that gets a list of tickets with 
only the ticket ID, the user, and the price:
async def get_events_tickets_with_user_price(
    db_session: AsyncSession, event_id: int
) -> list[Ticket]:
    query = (
        select(Ticket)
        .where(Ticket.event_id == event_id)
        .options(
            load_only(
                Ticket.id, Ticket.use
Integrating FastAPI with SQL Databases
156
You will notice that each element only has the id, user, and price fields and it will give an error 
if you attempt to access the show field, for example. In larger applications, this can reduce memory 
usage and make responses much faster.
There’s more…
SQL query optimization involves more than what the recipe showed. Often, choosing a certain SQL 
database depends on specific optimization needs.
Different SQL databases may have different strengths and weaknesses in handling these factors, 
depending on their architecture and features. For example, some SQL databases may support partitioning, 
sharding, replication, or distributed processing, which can improve the scalability and availability of 
data. Some SQL databases may offer more advanced query optimization techniques, such as cost-based 
optimization, query rewriting, or query caching, which can reduce the execution time and resource 
consumption of queries. Some SQL databases may impl
Securing sensitive data in SQL databases
157
How to do it…
We will make a new table from the ground up to store credit card information. Some of the information, 
such as credit card numbers and Card Verification Values (CVV), will not be saved in clear text in 
our database but rather encrypted. Since we need to get it back, we will use a symmetric encryption 
that needs a key. Let's make the process through the following steps.
1.	
Let’s start by creating a class in the database.py module that corresponds to the credit_card 
table in our database, as follows:
class CreditCard(Base):
    __tablename__ = "credit_cards"
    id: Mapped[int] = mapped_column(primary_key=True)
    number: Mapped[str]
    expiration_date: Mapped[str]
    cvv: Mapped[str]
    card_holder_name: Mapped[str]
2.	
Next, in the app folder, we create a module named security.py where we will write our 
code for encrypting and decrypting data using Fernet symmetric encryption, as follows:
from cryptography.fernet impo
Integrating FastAPI with SQL Databases
158
    return cypher_suite.decrypt(
        encrypted_card_info.encode()
    ).decode()
Those functions will be used when writing and reading from the database.
4.	
Then, we can write a storing operation in the same security.py module as follows:
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from app.database import CreditCard
async def store_credit_card_info(
    db_session: AsyncSession,
    card_number: str,
    card_holder_name: str,
    expiration_date: str,
    cvv: str,
):
    encrypted_card_number = encrypt_credit_card_info(
        card_number
    )
    encrypted_cvv = encrypt_credit_card_info(cvv)
    # Store encrypted credit card information
    # in the database
    credit_card = CreditCard(
        number=encrypted_card_number,
        card_holder_name=card_holder_name,
        expiration_date=expiration_date,
        cvv=encrypted_cvv,
    )
    async with db_session.begin():
        db_session.add(cr
Securing sensitive data in SQL databases
159
5.	
Similarly, we can define a function to retrieve the encrypted credit card information from the 
database as follows:
async def retrieve_credit_card_info(
    db_session: AsyncSession, credit_card_id: int
):
    query = select(CreditCard).where(
        CreditCard.id == credit_card_id
    )
    async with db_session as session:
        result = await session.execute(query)
        credit_card = result.scalars().first()
    credit_card_number = decrypt_credit_card_info(
            credit_card.number
        ),
    cvv = decrypt_credit_card_info(credit_card.cvv)
    card_holder = credit_card.card_holder_name
    expiry = credit_card.expiration_date
    return {
        "card_number": credit_card_number,
        "card_holder_name": card_holder,
        "expiration_date": expiry,
        "cvv": cvv
    }
We have just developed code to save confidential information in our database.
Exercise
We just saw the backbone of how to store sensitive d
Integrating FastAPI with SQL Databases
160
See also
We have used Fernet symmetric encryption to encrypt credit card information. You can have a deeper 
insight about it at the following link:
•	 Fernet symmetric encryption: https://cryptography.io/en/latest/fernet/
Handling transactions and concurrency
In the realm of database management, two critical aspects govern the reliability and performance of 
applications: handling transactions and managing concurrency.
Transactions, encapsulating a series of database operations, are fundamental for maintaining data 
consistency by ensuring that changes occur as a single unit of work. Concurrency, on the other hand, 
addresses the challenge of managing simultaneous access to shared resources by multiple users 
or processes.
The relationship between transactions and concurrency becomes apparent when considering scenarios 
where multiple transactions may attempt to access or modify the same data concurrently. Without 
proper concurrency control 
Handling transactions and concurrency
161
        update(Ticket)
        .where(
            and_(
                Ticket.id == ticket_id,
                Ticket.sold == False,
            )
        )
        .values(user=user, sold=True)
    )
    async with db_session as session:
        result = (
           await db_session.execute(ticket_query)
        )
        await db_session.commit()
        if result.rowcount == 0:
            return False
    return True
The query will only sell the ticket if the ticket has not been sold yet; otherwise, the function 
will return False.
2.	
Let’s try to add a ticket to our database and try to simulate two users buying the same ticket at 
the same time. Let’s write all in the form of unit tests.
We start by defining a fixture to write our ticket into the database in the tests/conftest.py 
file as follows:
@pytest.fixture
async def add_special_ticket(db_session_test):
    ticket = Ticket(
        id=1234,
        show="Special Show",
        de
Integrating FastAPI with SQL Databases
162
3.	
We can create a test by performing two concurrent sales with two separate database 
sessions (define another one as a different fixture) to do them at the same time in the 
tests/test_operations.py file:
import asyncio
async def test_concurrent_ticket_sales(
    add_special_ticket,
    db_session_test,
    second_session_test,
):
    result = await asyncio.gather(
        sell_ticket_to_user(
            db_session_test, 1234, "Jake Fake"
        ),
        sell_ticket_to_user(
            second_session_test, 1234, "John Doe"
        ),
    )
    assert result in (
        [True, False],
        [False, True],
    )  # only one of the sales should be successful
    ticket = await get_ticket(db_session_test, 1234)
    # assert that the user who bought the ticket
    # correspond to the successful sale
    if result[0]:
        assert ticket.user == "Jake Fake"
    else:
        assert ticket.user == "John Doe"
In the test function, we run 
Handling transactions and concurrency
163
The test will succeed, which means that the asynchronous session handles transaction conflicts.
Exercise
You have just created a draft of the selling ticket operation. As an exercise, you can improve 
the draft by doing the following:
- Adding a table for users to the database
- Adding the foreign key reference of the user on the ticket to make it sold
- Creating an alembic migration for the database modification
- Creating an API endpoint that exposes the sell_ticket_to_user function
There’s more…
One of the fundamental challenges of database systems is to handle concurrent transactions from 
multiple users while preserving data consistency and integrity. Different types of transactions may have 
different requirements for how they access and modify data and how they deal with other transactions 
that may conflict with them. For example, a common way to manage concurrency is to use locks, which 
are mechanisms that prevent unauthorized or inco
Integrating FastAPI with SQL Databases
164
2.	
READ COMMITTED:
	 Transactions at this level only see changes committed by other transactions.
	 They do not allow dirty reads.
	 Non-repeatable reads are possible, but phantom reads can still occur.
	 This level strikes a balance between concurrency and consistency.
3.	
REPEATABLE READ:
	 Transactions at this level see a consistent snapshot of the data throughout the transaction.
	 Changes committed by other transactions after the transaction began are not visible.
	 Non-repeatable reads are prevented, but phantom reads can occur.
	 This level provides stronger consistency at the cost of some concurrency.
4.	
SERIALIZABLE:
	 Transactions at this level behave as if they are executed serially – that is, one after another.
	 They provide the highest level of data consistency.
	 Non-repeatable reads and phantom reads are prevented.
	 This level offers strong consistency but may result in reduced concurrency due to 
increased locki
Handling transactions and concurrency
165
All these choices in terms of locks and isolation level affect the architecture and design of the database 
system since not all SQL databases support it. Therefore, it is important to understand the principles 
and best practices of locking strategies and how they relate to the transaction behavior and the 
business logic.
You have just completed a comprehensive overview of integrating SQL databases with FastAPI. In the 
next chapter, we will explore integrating FastAPI applications with NoSQL databases.
See also
You can find more information about locking strategies for SQLite and PostgreSQL at the following links:
•	 SQLite locking: https://www.sqlite.org/lockingv3.html
•	 PostgreSQL locking: https://www.postgresql.org/docs/current/explicit-
locking.html
Information on the isolation level for singular databases can be found on the respective 
documentation pages:
•	 SQLite isolation: https://www.sqlite.org/isolation.html
•	 MySQL isolation l

7
Integrating FastAPI 
with NoSQL Databases
In this chapter, we will explore the integration of FastAPI with NoSQL databases. By crafting the 
backend of a music streaming platform application, you will learn how to set up and use MongoDB, 
a popular NoSQL database, with FastAPI.
You will also learn how to perform create, read, update and delete (CRUD) operations, work with 
indexes for performance optimization, and handle relationships in NoSQL databases. Additionally, 
you will learn how to integrate FastAPI with Elasticsearch for powerful search capabilities, secure 
sensitive data, and implement caching using Redis.
By the end of this chapter, you will have a solid understanding of how to effectively use NoSQL databases 
with FastAPI to improve the performance and functionality of your applications.
In this chapter, we’re going to cover the following recipes:
•	 Setting up MongoDB with FastAPI
•	 CRUD operations in MongoDB
•	 Handling relationships in NoSQL databases
•	 Working wit
Integrating FastAPI with NoSQL Databases
168
Technical requirements
To follow along with the recipes of the chapter, ensure your setup includes the following essentials:
•	 Python: A version 3.7 or higher should be installed on your computer
•	 FastAPI: Have the fastapi package in your working environment
•	 asyncio: Be familiar with the asyncio framework and async/await syntax since we 
will use it all along the recipes
The code used in the chapter is hosted on GitHub at this address: https://github.com/
PacktPublishing/FastAPI-Cookbook/tree/main/Chapter07.
You can create a virtual environment for the project within the project root folder to manage 
dependencies efficiently and maintain project isolation.
Within your virtual environment, you can install all the dependencies at once by using 
requirements.txt, which is provided on the GitHub repository in the project folder:
$ pip install –r requirements.txt
General knowledge of the external tools we are going to use for each recipe c
Setting up MongoDB with FastAPI
169
You also need the motor package installed in your environment. If you haven’t installed the packages 
with requirements.txt, you can install motor in your environment from the command line:
$ pip install motor
Motor is the asynchronous Python driver developed by MongoDB Inc and it allows Python code to 
interact with MongoDB through the asyncio library.
Once we have the MongoDB instance running and reachable and the motor package installed in 
your environment, we can proceed with the recipe.
How to do it…
Let’s start by creating a project root folder called streaming_platform with an app subfolder. 
In app, we create a module called db_connection.py, which will contain the information on 
the connection with MongoDB.
Now, we will set up the connection through the following steps:
1.	
In the db_connecion.py module, let’s define the MongoDB client:
from motor.motor_asyncio import AsyncIOMotorClient
mongo_client = AsyncIOMotorClient(
    "mongodb://loc
Integrating FastAPI with NoSQL Databases
170
        logger.error(
            f"Error connecting to MongoDB: {e}"
        )
        raise e
The function will ping the server, and if it doesn’t receive any response, it will propagate an 
error that will stop the code from running.
4.	
Finally, we need to run the ping_mongo_db_server function when starting the FastAPI 
server. In the app folder, let’s create a main.py module with a context manager that will be 
used for the startup and shutdown of our FastAPI server:
from contextlib import asynccontextmanager
from app.db_connection import (
    ping_mongo_db_server,
)
@asynccontextmanager
async def lifespan(app: FastAPI):
    await ping_mongo_db_server(),
    yield
The lifespan context manager has to be passed as an argument to the FastAPI object:
from fastapi import FastAPI
app = FastAPI(lifespan=lifespan)
The server is wrapped in the lifespan context manager to execute the database check at startup.
To test it, make sure your MongoDB 
CRUD operations in MongoDB
171
See also
You can see more on the Motor asynchronous driver on the MongoDB official documentation page:
•	 Motor Async Driver Setup: https://www.mongodb.com/docs/drivers/motor/
For startups and shutdown events of the FastAPI server, you can find more on this page:
•	 FastAPI Lifespan Events: https://fastapi.tiangolo.com/advanced/events/
CRUD operations in MongoDB
CRUD operations form the cornerstone of data manipulation in databases, enabling users to create, 
read, update, and delete data entities with efficiency, flexibility, and scalability.
This recipe will demonstrate how to create endpoints in FastAPI for creating, reading, updating, and 
deleting a document from a MongoDB database for the backbone of our streaming platform.
Getting ready
To follow along with the recipe, you need a database connection with MongoDB already in place with 
your application, otherwise, go to the previous recipe, Setting up MongoDB with FastAPI, which will 
show you in de
Integrating FastAPI with NoSQL Databases
172
In the same module, we can create the function to return the database that will be used as a dependency 
in the endpoints for code maintainability:
def mongo_database():
    return database
Now, we can define our endpoints in main.py for each of the CRUD operations through the 
following steps.
1.	
Let’s start by creating the endpoint to add a song to the songs collection:
from bson import ObjectId
from fastapi import Body, Depends
from app.database import mongo_database
from fastapi.encoders import ENCODERS_BY_TYPE
ENCODERS_BY_TYPE[ObjectId] = str
@app.post("/song")
async def add_song(
    song: dict = Body(
        example={
            "title": "My Song",
            "artist": "My Artist",
            "genre": "My Genre",
        },
    ),
    mongo_db=Depends(mongo_database),
):
    await mongo_db.songs.insert_one(song)
    return {
        "message": "Song added successfully",
        "id": song["_id"],
    }
The endpoint takes a genera
CRUD operations in MongoDB
173
One of the reasons to choose a NoSQL database is the freedom from SQL schema, which 
allows for more flexibility in managing data. However, it can be helpful to provide an example 
to follow in the documentation. This is achieved by using the Body object class with the 
example parameter.
2.	
The endpoint to retrieve a song will be quite straightforward:
@app.get("/song/{song_id}")
async def get_song(
    song_id: str,
    db=Depends(mongo_database),
):
    song = await db.songs.find_one(
        {
            "_id": ObjectId(song_id)
            if ObjectId.is_valid(song_id)
            else None
        }
    )
    if not song:
        raise HTTPException(
            status_code=404,
            detail="Song not found"
        )
    return song
The application will search for a song with the specified ID and return a 404 error if none 
is found.
3.	
To update a song, the endpoint will look like this:
@app.put("/song/{song_id}")
async def update_song(
 
Integrating FastAPI with NoSQL Databases
174
    if result.modified_count == 1:
      return {
          "message": "Song updated successfully"
      }
    raise HTTPException(
        status_code=404, detail="Song not found"
    )
The endpoint will return a 404 error if the song id does not exist, otherwise it will update only 
the fields specified in the body request.
4.	
Finally, the delete operation endpoint can be done as follows:
@app.delete("/song/{song_id}")
async def delete_song(
    song_id: str,
    db=Depends(mongo_database),
):
    result = await db.songs.delete_one(
        {
            "_id": ObjectId(song_id)
            if ObjectId.is_valid(song_id)
            else None
        }
    )
    if result.deleted_count == 1:
        return {
            "message": "Song deleted successfully"
        }
    raise HTTPException(
        status_code=404, detail="Song not found"
    )
You have just created the endpoints to interact with a MongoDB database.
Now, spin up the serv
Handling relationships in NoSQL databases
175
If you follow along with the GitHub repository, you can also prefill the database with the script 
fill_mongo_db_database.py at the link: https://github.com/PacktPublishing/
FastAPI-Cookbook/blob/main/Chapter07/streaming_platform/fill_mongo_
db_database.py
Make sure you download also the songs_info.py in the same folder.
You can then run the script from the terminal as follows:
$ python fill_mongo_db_database.py
If you call the endpoint GET /songs you will have a long list of songs pre filled to test your API.
See also
You can investigate the operations provided by motor to interact with a MongoDB instance further 
at the official documentation link:
•	 Motor MongoDB Aynscio Tutorial: https://motor.readthedocs.io/en/stable/
tutorial-asyncio.html
Handling relationships in NoSQL databases
Unlike relational databases, NoSQL databases do not support joins or foreign keys for defining 
relationships between collections.
Schema-less databases, su
Integrating FastAPI with NoSQL Databases
176
Getting ready
We will continue building our streaming platform. Make sure you have followed all the previous recipes 
in this chapter, or you can apply the steps to an existing application that interacts with a NoSQL database.
How to do it…
Let’s see how to implement relationships for both embedding and referencing techniques.
Embedding
A suitable candidate to showcase embedded relationships for songs is a collection of albums. Album 
information does not change often, if not never, once it is published.
The album document will embedded into the song document with a nested field:
{
    "title": "Title of the Song",
    "artist": "Singer Name",
    "genre": "Music genre",
    "album": {
        "title": "Album Title",
        "release_year": 2017,
    },
}
When using MongoDB, we can retrieve information about an album and a song using the same 
endpoint. This means that when we create a new song, we can directly add information about the 
alb
Handling relationships in NoSQL databases
177
Referencing
A typical use case for referencing relationships can be the creation of a playlist. A playlist contains 
multiple songs, and each song can appear in different playlists. Furthermore, playlists are often changed 
or updated, so it respond to the need for a referencing strategy to manage relationships.
On the database side, we don’t need any action so we will directly proceed to create the endpoint to 
create the playlist and the one to retrieve the playlist with all song information.
1.	
You can define the endpoint to create a playlist in the main.py module:
class Playlist(BaseModel):
    name: str
    songs: list[str] = []
@app.post("/playlist")
async def create_playlist(
    playlist: Playlist = Body(
        example={
            "name": "My Playlist",
            "songs": ["song_id"],
        }
    ),
    db=Depends(mongo_database),
):
    result = await db.playlists.insert_one(
        playlist.model_dump()
    )
    return 
Integrating FastAPI with NoSQL Databases
178
    playlist = await db.playlists.find_one(
        {
            "_id": ObjectId(playlist_id)
            if ObjectId.is_valid(playlist_id)
            else None
        }
    )
    if not playlist:
        raise HTTPException(
            status_code=404,
            detail="Playlist not found"
        )
    songs = await db.songs.find(
        {
            "_id": {
                "$in": [
                    ObjectId(song_id)
                    for song_id in playlist["songs"]
                ]
            }
        }
    ).to_list(None)
    return {
        "name": playlist["name"],
        "songs": songs
    }
Notice that the song IDs in the playlist collection are stored as strings, not ObjectId, which 
means that they have to be converted when queried.
Also, to receive the list of songs for the playlist, we had to make two queries: one for the playlist 
and one to retrieve the songs based on their IDs.
Now that you build the endpoi
Working with indexes in MongoDB
179
At this point, you have all the tools to manage relationships between collections in MongoDB.
See also
We just saw how to manage relationships with MongoDB and create relative endpoints. Feel free to 
check the official MongoDB guidelines at this link:
•	 MongoDB Model Relationships: https://www.mongodb.com/docs/manual/
applications/data-models-relationships/
Working with indexes in MongoDB
An index is a data structure that provides a quick lookup mechanism for locating specific pieces of data 
within a vast dataset. Indexes are crucial for enhancing query performance by enabling the database 
to quickly locate documents based on specific fields.
By creating appropriate indexes, you can significantly reduce the time taken to execute queries, 
especially for large collections. Indexes also facilitate the enforcement of uniqueness constraints and 
support the execution of sorted queries and text search queries.
In this recipe, we’ll explore the concept
Integrating FastAPI with NoSQL Databases
180
The query will fetch all documents and filter the one with a certain release_year. To speed up 
the query, we can create a dedicated index on the release year. We can do it at the server startup in 
the lifespan context manager in main.py. A text search in MongoDB won’t be possible without 
a text index.
First, at the startup server, let’s create a text index based on the artist field of the collection document. 
To do this, let’s modify the lifespan context manager in the main.py module:
@asynccontextmanager
async def lifespan(app: FastAPI):
    await ping_mongo_db_server(),
    db = mongo_database()
    await db.songs.create_index({"album.release_year": -1})
    yield
The create_index method will create an index based on the release_year field sorted in 
descending mode because of the -1 value.
You’ve just created an index based on the release_year field.
How it works…
The index just created is automatically used by MongoDB when running th
Working with indexes in MongoDB
181
The explained_query variable holds information about the query such as the query execution 
or index used for the search.
If you run the server and call the GET /songs/year endpoint, you will see the following message 
log on the terminal output:
INFO:    Index used: album.release_year_-1
This confirms that the query has correctly used the index we created to run.
There’s more…
Database indexes become necessary to run text search queries. Imagine we need to retrieve the songs 
of a certain artist.
To query and create the endpoint, we need to make a text index on the artist field. We can do it 
at the server startup like the previous index on album.release_year.
In the lifespan context manager, you can add the index creation:
@asynccontextmanager
async def lifespan(app: FastAPI):
    await ping_mongodb_server(),
    db = mongo_database()
    await db.songs.drop_indexes()
    await db.songs.create_index({"release_year": -1})
    await db.songs.create_i
Integrating FastAPI with NoSQL Databases
182
        "Index used: %s",
        explained_query.get("queryPlanner", {})
        .get("winningPlan", {})
        .get("indexName", "No index used"),
    )
    songs = await query.to_list(None)
    return songs
Spin up the server from the command line with the following:
$ uvicorn app.main:app
Go to the interactive documentation at http:/localhost:8000/docs and try to run the new 
GET /songs/artist endpoint.
Text searching allow you to fetch records based on text matching. If you have filled the database with 
the fill_mongo_db_database.py script you can try searching for Bruno Mars’s songs by 
specifying the family name "mars". The query will be:
http://localhost:8000/songs/artist?artist=mars
This will return at the least the song:
[
  {
    "_id": "667038acde3a00e55e764cf7",
    "title": "Uptown Funk",
    "artist": "Mark Ronson ft. Bruno Mars",
    "genre": "Funk/pop",
    "album": {
      "title": "Uptown Special",
      "release_year": 
Exposing sensitive data from NoSQL databases
183
Important note
By using the explanation_query variable, you can also check the difference in the 
execution time. However, you need a huge number of documents in your collection to appreciate 
the improvement.
See also
We saw how to build a text index for the search over the artist and a numbered index for the year of 
release. MongoDB allows you to do more, such as defining 2D sphere index types or compound indexes. 
Have a look at the documentation to discover the potential of indexing your MongoDB database:
•	 Mongo Indexes: https://www.mongodb.com/docs/v5.3/indexes/
•	 MongoDB Text Search: https://www.mongodb.com/docs/manual/core/link-
text-indexes/
Exposing sensitive data from NoSQL databases
The way to expose sensitive data in NoSQL databases is pivotal to protecting sensitive information 
and maintaining the integrity of your application.
In this recipe, we will demonstrate how to securely view our data through database aggregatio
Integrating FastAPI with NoSQL Databases
184
    "country": "USA",
    "consent_to_share_data": True,
    "actions": [
        {
            "action": "basic subscription",
            "date": "2021-01-01",
            "amount": 10,
        },
        {
            "action": "unscription",
            "date": "2021-05-01",
        },
    ],
}
The consent_to_share_data field stores the consent of the user to share behavioral data with 
third-party partners.
Let’s first fill the collection users in our database. You can do this with a user’s sample by running the 
script provided in the GitHub repository:
$ python fill_users_in_mongo.py
If everything runs smoothly, you should have the collection users in your MongoDB instance.
How to do it…
Imagine we need to expose users data for marketing research to a third-party API consumer for 
commercial purposes. The third-party consumer does not need PII information such as names or 
emails, and they are also not allowed to have data from users 
Exposing sensitive data from NoSQL databases
185
Since we don’t have any need to manage high traffic, we will use the simple pymongo client 
instead of the asynchronous one. We will reserve the asynchronous to the sole use of the 
application interactions.
2.	
The pipeline stage follows a specific aggregations framework. The first step of the pipeline will be 
to filter out the users who didn’t approve the consent. This can be done with a $redact stage:
pipeline_redact = {
    "$redact": {
        "$cond": {
            "if": {
                "$eq": [
                    "$consent_to_share_data", True
                ]
            },
            "then": "$$KEEP",
            "else": "$$PRUNE",
        }
    }
}
3.	
Then, we filter out the emails that shouldn’t be shared with a $unset stage:
pipeline_remove_email_and_name = {
    "$unset": ["email", "name"]
}
4.	
This part of the pipeline will prevent emails and names from appearing in the pipeline’s output. 
We will split stage defini
Integrating FastAPI with NoSQL Databases
186
5.	
Then, we map the new date field for each element of the actions list:
rebuild_actions_elements = {
    "input": "$actions",
    "as": "action",
    "in": {
        "$mergeObjects": [
            "$$action",
            {"date": obfuscate_day_of_date},
        ]
    },
}
6.	
Then, we use a $set operation to apply the rebuild_actions_element operation to 
every record like that:
pipeline_set_actions = {
    "$set": {
        "actions": {"$map": rebuild_actions_elements},
    }
}
7.	
Then, we gather the pipelines just created to define the entire pipeline stage:
pipeline = [
    pipeline_redact,
    pipeline_remove_email_and_name,
    pipeline_set_actions,
]
8.	
We can use the list of aggregation stages to retrieve results and create the view in the __main__ 
section of the script:
if __name__ == "__main__":
    client["beat_streaming"].drop_collection(
        "users_data_view"
    )
    client["beat_streaming"].create_collection(
        
Exposing sensitive data from NoSQL databases
187
Say you run the script, from the terminal, for example, as follows:
$ python create_aggregation_and_user_data_view.py
The users_data_view view will be created in our beat_streaming database.
9.	
Once we have the view, we can create a dedicated endpoint to expose this view to a third-party 
customer without exposing any sensible data. We can create our endpoint in a separate module 
for clarity. In the app folder, let’s create the third_party_endpoint.py module. In the 
module, let’s create the module router as follows:
from fastapi import APIRouter, Depends
from app.database import mongo_database
router = APIRouter(
    prefix="/thirdparty",
    tags=["third party"],
)
10.	 Then, we can define the endpoint:
@router.get("/users/actions")
async def get_users_with_actions(
    db=Depends(mongo_database),
):
    users = [
        user
        async for user in db.users_data_view.find(
            {}, {"_id": 0}
        )
    ]
    return use
Integrating FastAPI with NoSQL Databases
188
The endpoint is now implemented in our API. Let’s start the server by running the following command:
$ uvicorn app.main:app
At http://localhost:8000/docs, you can check that the newly created endpoint is present 
and call it to retrieve all the users from the created view without any sensible information.
You have just created an endpoint that securely exposes users data. An additional layer of security can 
be added by implementing role-based access control (RBAC) on the endpoint as we have done, for 
example, in Chapter 4, Authentication and Authorization, in the recipe Setting up RBAC.
There’s more…
Additional layers are often added to secure your data’s application, besides data masking. The most 
important ones are as follows:
•	 Encryption at rest
•	 Encryption in transit
•	 RBAC
The three services are provided as ready-to-use solutions in enterprise versions of MongoDB. The 
choice of using it or not is at the discretion of software a
Integrating FastAPI with Elasticsearch
189
See also
In the recipe, we had a quick look at how to create aggregations and views in MongoDB. Feel free to 
look into this more on the official documentation pages:
•	 MongoDB Aggregations Quickstart: https://www.mongodb.com/developer/
languages/python/python-quickstart-aggregation/
•	 MongoDB Views Documentation: https://www.mongodb.com/docs/manual/core/
views/
A good example of pushing data masking forward through database aggregations in MongoDB can 
be found at this link:
•	 MongoDB Data Masking Example: https://github.com/pkdone/mongo-data-
masking?tab=readme-ov-file
You can see more about the commands of the aggregation framework on the official documentation page:
•	 Aggregation Stage: https://www.mongodb.com/docs/manual/reference/
operator/aggregation-pipeline/
Also, a comprehensive book on MongoDB aggregations, free to consult, is available at this link:
•	 Practical MongoDB Aggregation Book: https://www.practical-mongodb-
aggregati
Integrating FastAPI with NoSQL Databases
190
Furthermore, you need an Elasticsearch instance running and reachable at this address: 
http://localhost:9200.
You can also install Elasticsearch on your machine by following the official guide: https://
www.elastic.co/guide/en/elasticsearch/reference/current/install-
elasticsearch.html.
Then, if you haven’t installed the packages with requirements.txt, you need to install the 
Elasticsearch Python client with the aiohttp package in your environment. You can do this with 
pip from the command line:
$ pip install "elasticsearch>=8,<9" aiohttp
A basic knowledge of Domain Specific Language (DSL) in Elasticsearch can be beneficial to get a 
deeper understanding of the queries we are going to implement.
Have a look at the official documentation at this link: https://www.elastic.co/guide/
en/elasticsearch/reference/current/query-dsl.html.
Once you have Elasticsearch installed and running, we can proceed to integrate it into our application.
How to
Integrating FastAPI with Elasticsearch
191
We can create a function to check the connection with Elasticsearch in the same module:
from elasticsearch import (
    TransportError,
)
async def ping_elasticsearch_server():
    try:
        await es_client.info()
        logger.info(
            "Elasticsearch connection successful"
        )
    except TransportError as e:
        logger.error(
            f"Elasticsearch connection failed: {e}"
        )
        raise e
The function will ping the Elasticsearch server and propagate an error if the ping fails.
Then, we can call the function at the FastAPI server startup in the lifetime context manager in 
the main.py module:
@asynccontextmanager
async def lifespan(app: FastAPI):
    await ping_mongo_db_server(),
    await ping_elasticsearch_server()
# rest of the code
This will ensure that the application checks the connection with the Elasticsearch server at the startup, 
and it will propagate an error if the Elasticsearch server does not
Integrating FastAPI with NoSQL Databases
192
    "title": "Album Title",
    "release_year": 2012,
    },
    "genre": "rock pop",
    "views_per_country": {
    "India": 50_000_000,
    "UK": 35_000_150_000,
    "Mexico": 60_000_000,
    "Spain": 40_000_000,
    },
}
You can find a list of sampling songs in the file songs_info.py in the project GitHub repository. 
If you use the file, you can also define a function to fill in the index as:
from app.db_connection import es_client
async def fill_elastichsearch():
    for song in songs_info:
        await es_client.index(
            index="songs_index", body=song
        )
    await es_client.close()
To group our songs based on the country’s views, we will need to fetch data based on the views_
per_country field, and for the top ten artists, we will group based on the artist field.
This information should be provided to the indexing process so that Elasticsearch understands how 
to index documents within the index for running queries.
I
Integrating FastAPI with Elasticsearch
193
    }
}
The mapping object will be passed as an argument to the Elasticsearch client when creating the 
index. We can define a function to create our songs_index:
from app.db_connection import es_client
async def create_index():
    await es_client.options(
        ignore_status=[400, 404]
    ).indices.create(
        index="songs_index",
        body=mapping,
    )
    await es_client.close()
You can run the function in into a grouping main() one, and use the __main__ section of the 
module to run as follows:
async def main():
    await create_index()
    await fill_elastichsearch() # only if you use it
if __name__ == "__main__":
    import asyncio
    asyncio.run(create_index())
You can then run the script from the terminal:
$ python fill_elasticsearch_index.py
Now that the index is created, we just have to add the songs to the index. You can do this by creating 
a separate script or by running fill_elasticsearch_index.py, which is provided
Integrating FastAPI with NoSQL Databases
194
Build the query
We will build a function to return the query based on the specified country.
We can do it in a separate module in the app folder called es_queries.py. The query should 
fetch all the documents containing the views_per_country map index for the country and sort 
the results in descending order:
def top_ten_songs_query(country) -> dict:
    views_field = f"views_per_country.{country}"
    query = {
        "bool": {
            "must": {"match_all": {}},
            "filter": [
                {"exists": {"field": views_field}}
            ],
        }
    }
    sort = {views_field: {"order": "desc"}}
Then, we filter the fields that we want in the response as follows:
    source = [
        "title",
        views_field,
        "album.title",
        "artist",
    ]
Finally, we return the query in the form of a dictionary by specifying the size of the list we will expect:
      return {
        "index": "songs_index",
        "
Integrating FastAPI with Elasticsearch
195
Create the FastAPI endpoint
Once we have set up the Elasticsearch connection and formulated the query, creating the endpoint is 
a straightforward process. Let’s define it in a new module called main_search.py under the app 
folder. Let’s start by defining the router:
from fastapi import APIRouter
router = APIRouter(prefix="/search", tags=["search"])
Then, the endpoint will be:
from fastapi import Depends, HTTPException
from app.db_connection import es_client
def get_elasticsearch_client():
    return es_client
@router.get("/top/ten/artists/{country}")
async def top_ten_artist_by_country(
    country: str,
    es_client=Depends(get_elasticsearch_client),
):
    try:
        response = await es_client.search(
         *top_ten_artists_query(country)
    )
    except BadRequestError as e:
        logger.error(e)
        raise HTTPException(
            status_code=400,
            detail="Invalid country",
        )
    return [
        {
      
Integrating FastAPI with NoSQL Databases
196
        ]["buckets"]
    ]
The result of the query is further adjusted before being returned to extract only the values we are 
interested in, namely the artist and views.
The last step is to include the router in our FastAPI object to include the endpoint.
In the main.py module, we can add the router as follows:
import main_search
## existing code in main.py
app = FastAPI(lifespan=lifespan)
app.include_router(third_party_endpoint.router)
app.include_router(main_search.router)
## rest of the code
Now, if you spin up the server with the uvicorn app.main:app command and go to the interactive 
documentation at http://localhost:8000/docs, you will see the newly created endpoint to 
retrieve the top ten artists in a country based on the views of the songs.
You have just created a FastAPI endpoint that interacts with an Elasticsearch instance. Feel free to 
create new endpoints on your own. For example, you can create an endpoint to return the top
Using Redis for caching in FastAPI
197
You can find a guide to mapping at this link:
•	 Mapping: https://www.elastic.co/guide/en/elasticsearch/reference/
current/mapping.html
Finally, you can dig into the search query language at the following link:
•	 Query DSL: https://www.elastic.co/guide/en/elasticsearch/reference/
current/query-dsl.html
Using Redis for caching in FastAPI
Redis is an in-memory data store that can be used as a cache to improve the performance and scalability 
of FastAPI applications. By caching frequently accessed data in Redis, you can reduce the load on 
your database and speed up response times for your API endpoints.
In this recipe, we’ll explore how to integrate Redis caching into our streaming platform application 
and we will cache an endpoint as an example.
Getting ready
To follow along with the recipe you need a running Redis instance reachable at the http://
localhost:6379 address.
Depending on your machine and your preference, you have several ways to ins
Integrating FastAPI with NoSQL Databases
198
How to do it…
Once Redis is running and reachable at localhost:6379, we can integrate the Redis client into 
our code:
1.	
In the db_connection.py module, where we already defined the clients for Mongo and 
Elasticsearch, let’s add the client for Redis:
from redis import asyncio as aioredis
redis_client = aioredis.from_url("redis://localhost")
2.	
Similarly to the other databases, we can create a function that pings the Redis server at the 
application’s startup. The function can be defined as follows:
async def ping_redis_server():
    try:
        await redis_client.ping()
        logger.info("Connected to Redis")
    except Exception as e:
        logger.error(
            f"Error connecting to Redis: {e}"
        )
        raise e
3.	
Then, include it in the lifespan context manager in main.py:
@asynccontextmanager
async def lifespan(app: FastAPI):
    await ping_mongo_db_server(),
    await ping_elasticsearch_server(),
    await ping_re
Using Redis for caching in FastAPI
199
5.	
Then, you can modify the endpoint as follows:
@router.get("/top/ten/artists/{country}")
async def top_ten_artist_by_country(
    country: str,
    es_client=Depends(get_elasticsearch_client),
    redis_client=Depends(get_redis_client),
):
6.	
At the beginning of the function, we retrieve the key to store the value and check whether the 
value is already stored in Redis:
    cache_key = f"top_ten_artists_{country}"
    cached_data = await redis_client.get(cache_key)
    if cached_data:
        logger.info(
            f"Returning cached data for {country}"
        )
        return json.loads(cached_data)
7.	
Then, when we see that the data is not present, we continue by getting the data from Elasticsearch:
    try:
        response = await es_client.search(
             *top_ten_artists_query(country)
        )
    except BadRequestError as e:
        logger.error(e)
        raise HTTPException(
            status_code=400,
            detail="
Integrating FastAPI with NoSQL Databases
200
            "top_ten_artists"
        ]["buckets"]
    ]
8.	
Once we retrieve the list, we store it in Redis so we can retrieve it at the following call:
    await redis_client.set(
        cache_key, json.dumps(artists), ex=3600
    )
    return artists
9.	
We specified an expiring time, which is the time the record will stay in Redis in seconds. After that 
time, the record won’t be available anymore and the artists list will be recalled from Elasticsearch.
Now, if you run the server with the uvicorn app.main:app command and try to call the endpoint 
for Italy, you will notice that the response time for the second call will be much less.
You have just implemented a cache for one of the endpoints of our application with Redis. With the 
same strategy, feel free to cache all the other endpoints.
There’s more…
At the time of writing, there is a promising library, fastapi-cache, which makes caching in FastAPI 
very easy. Check the GitHub repos
8
Advanced Features 
and Best Practices
Welcome to Chapter 8, where we explore advanced techniques and best practices to optimize the 
functionality, performance, and scalability of FastAPI applications.
In this chapter, by building a trip agency platform, you’ll delve into essential topics such as dependency 
injection, custom middleware, internationalization, performance optimization, rate limiting, and 
background task execution. By mastering these advanced features, you’ll be equipped to build robust, 
efficient, and high-performing APIs with FastAPI.
By the end of this chapter, you’ll have a comprehensive understanding of the advanced FastAPI 
features and best practices, empowering you to build efficient, scalable, and secure APIs that meet the 
demands of modern web applications. Let’s dive in and explore these advanced techniques to elevate 
your FastAPI development skills.
In this chapter, we’re going to cover the following recipes:
•	 Implementing dependency injection
•	 Crea
Advanced Features and Best Practices
202
Technical requirements
To be able to follow the recipes in this chapter, you must have a good grasp of the following essentials:
•	 Python: You should have a good understanding of Python version 3.7 or higher. You should 
know how annotation works and about basic class inheritance.
•	 fastapi and asyncio libraries: If you are not following the book chapter by chapter, make 
sure you know how to build a simple FastAPI endpoint and understand async/await syntax.
The code used in the chapter is hosted on GitHub at https://github.com/PacktPublishing/
FastAPI-Cookbook/tree/main/Chapter08.
To manage dependencies more efficiently and keep your project isolated, consider creating a virtual 
environment within the project root folder. You can easily install all the dependencies simultaneously 
by using the requirements.txt file provided on the GitHub repository in the project folder:
$  pip install –r requirements.txt
You can then start with the first re
Implementing dependency injection
203
How to do it…
Let's start by creating the project root folder called trip_platform containing the app folder. 
Then let's continue the recipe through the following steps.
1.	
In the app folder, create the main.py module that will contain the server as:
from fastapi import FastAPI
app = FastAPI()
We will write the dependencies in a separate module called dependencies.py inside the 
app folder.
2.	
Let’s imagine we need to create an endpoint to retrieve all the trips between a start date and an 
end date. We need to handle two parameters, the start date and end date, and check that the 
start date is earlier than the end date. Both parameters can be optional; if the start date is not 
provided, it defaults to the current day.
In a dedicated module, dependencies.py in the app folder, let’s define the condition 
function, which checks that the start date is earlier than the end date:
from fastapi import HTTPException
def check_start_end_condition(start
Advanced Features and Best Practices
204
        ),
        example=date.today().isoformat(),
    ),
    end: date | None = Query(
        None,
        example=date.today() + timedelta(days=7),
    ),
) -> Tuple[date, date | None]:
    check_start_end_condition(start, end)
    return start, end
The Query object is used to manage metadata of the query parameters, such as the default 
value, description, and example used when generating the documentation.
4.	
We can use the dependable time_range function to create the endpoint in the main.py 
module. To specify that it is a dependency, we use the Depends object like this:
from fastapi import Depends
@app.get("/v1/trips")
def get_tours(
    time_range = Depends(time_range),
):
    start, end = time_range
    message = f"Request trips from {start}"
    if end:
        return f"{message} to {end}"
    return message
You can alternatively use the Annotated class from the typing package to define the 
dependency as follows:
from typing impor
Implementing dependency injection
205
Important note
The use of Annotated in FastAPI is currently evolving to avoid duplicates and improve 
readability; take a look at the dedicated documentation section: https://fastapi.
tiangolo.com/tutorial/dependencies/#share-annotated-dependencies.
For the rest of the chapter, we will use the latest Annotated convention.
Now, if you spin up the server by running uvicorn app.main:app on the terminal, you will 
find the endpoint in the interactive documentation at http://localhost:8000/docs. You 
will see that you just created the endpoint with the parameters correctly documented. The database 
logic is replaced by a string construction returning a significant message in the example.
You have just implemented a dependency injection strategy to define query parameters for the endpoint. 
You can use the same strategy to write path or body parameters to write modular and readable code.
One of the advantages of using dependency injection is to logically
Advanced Features and Best Practices
206
    assert (
        response.json()
        == "Request trips from 2024-02-01"
    )
By overriding the time_range dependency, we won’t need to pass the parameters when calling the 
endpoint, and the response will depend on the lambda function defined.
Then, you can run the test from the command line:
$ pytest tests
This technique is very useful when writing tests that should not interfere with a production database. 
Also, an eventual heavy computation logic can be mocked if it is not in the test’s interest.
The use of dependency injection can significantly improve test quality by enabling modularity.
How it works…
The Depends object and dependency injection leverage Python’s powerful function annotations 
and type hinting features.
When you define a dependency function and annotate it with Depends, FastAPI interprets it as 
a dependency that needs to be resolved before executing the endpoint function. When a request is 
made to an endpoint tha
Implementing dependency injection
207
In the dependencies.py module, let’s create the dependable function for the category.
Imagine we can group our trips into three categories – cruises, city breaks, and resort stays. We 
need to add a parameter to retrieve trips only for a specific category. We will need a dependable 
function, as follows:
def select_category(
    category: Annotated[
        str,
        Path(
            description=(
                "Kind of travel "
                "you are interested in"
            ),
            enum=[
                "Cruises",
                "City Breaks",
                "Resort Stay",
            ],
        ),
    ],
) -> str:
    return category
Now, let’s imagine we need to validate a coupon for a discount.
The dependable function will be used as a dependency for another dependable function that 
will check the coupon. Let’s define it, as follows:
def check_coupon_validity(
    category: Annotated[select_category, Depends()],
    code: 
Advanced Features and Best Practices
208
        return True
    return False
In the main.py module, let’s define a new endpoint, GET /v2/trips/{category}, that returns 
the trips for the specified category:
@app.get("/v2/trips/{category}")
def get_trips_by_category(
    category: Annotated[select_category, Depends()],
    discount_applicable: Annotated[
        bool, Depends(check_coupon_validity)
    ],
):
    category = category.replace("-", " ").title()
    message = f"You requested {category} trips."
    if discount_applicable:
        message += (
            "\n. The coupon code is valid! "
            "You will get a discount!"
        )
    return message
If you run the server with the uvicorn app.main:app command and open the interactive 
documentation at http://localhost:8000/docs, you will see the new endpoint. The accepted 
parameters, category and code, both come from the dependencies, and the category parameter 
is not repeated within the code.
Important note
You can use
Creating custom middleware
209
See also
We have used Query and Path descriptor objects to set metadata and documentation-related data 
for query and path parameters, respectively. You can discover more about their potential at these 
documentation links:
•	 Query Parameters and String Validations: https://fastapi.tiangolo.com/tutorial/
query-params-str-validations/
•	 Path Parameters and Numeric Validations: https://fastapi.tiangolo.com/
tutorial/path-params-numeric-validations/
For dependency injections in FastAPI, you can find extensive documentation covering all the possible 
usages, explaining the potential of this powerful feature:
•	 Dependencies: https://fastapi.tiangolo.com/tutorial/dependencies/
•	 Advanced Dependencies: https://fastapi.tiangolo.com/advanced/advanced-
dependencies/
•	 Testing Dependencies with Overrides: https://fastapi.tiangolo.com/advanced/
testing-dependencies/
Creating custom middleware
Middleware is an API component that allows you to intercept and modify
Advanced Features and Best Practices
210
We want the middleware to intercept the request and print the host client and the method on 
the output terminal. In a real application scenario, this information can be stored in a database 
for analytics or used for security inspection purposes.
Let’s use the same uvicorn logger used by FastAPI by default:
import logging
logger = logging.getLogger("uvicorn.error")
2.	
Then, let’s create our ClientInfoMiddleware class, as follows:
from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware
class ClientInfoMiddleware(BaseHTTPMiddleware):
    async def dispatch(
        self, request: Request, call_next
    ):
        host_client = request.client.host
        requested_path = request.url.path
        method = request.method
        logger.info(
            f"host client {host_client} "
            f"requested {method} {requested_path} "
            "endpoint"
        )
        return await call_next(request)
3.	
Then, we 
Internationalization and localization
211
Now, spin up the server with the uvicorn app.main:app command, and try to connect to 
a subpath of http://localhost:8000/v1/trips. You don’t even need to call an existing 
endpoint. You will see the log messages in the application output terminal:
INFO:host client 127.0.0.1 requested GET /v1/trips endpoint
You have just implemented a basic custom middleware to retrieve information about the client. You 
can increase the complexity by adding more operations, such as redirecting requests based on the IP 
and integrating IP blocking or filtering.
How it works…
FastAPI uses the BasicHTTPMiddleware class from the Starlette library. The strategy shown 
in the recipe creates a class derived from BasicHTTPMiddleware, with a specific dispatch 
method that implements the interception operation.
To create a middleware in FastAPI, you can add a decorator from the FastAPI class methods to a 
simple function. However, it is recommended to create a class, as 
Advanced Features and Best Practices
212
The Accept-Language request HTTP header is the most commonly used method to inform a server 
about a user’s location. This is widely used by modern browsers. This recipe will guide you on how to 
utilize the Accept-Language header to implement i18n and l10n in our trip platform. This will 
enable our platform to provide targeted content to the client.
Getting ready
It would be beneficial to have some knowledge of the Accept-Language header; take a look at 
this interesting article from Mozilla’s documentation: https://developer.mozilla.org/
en-US/docs/Web/HTTP/Headers/Accept-Language.
You need to have a running FastAPI application to follow the recipe. You can follow along with the 
trip platform application used throughout the chapter.
We will make use of dependency injection, so it will be beneficial to complete the Implementing 
dependency injection recipe from this chapter.
Also, we will use the babel package to resolve language code referen
Internationalization and localization
213
We need a function that takes as an argument the header and the list of available languages in our app, 
returning the most appropriate one Let's implement it by applying the following steps.
1.	
Create a dedicated module, internationalization.py, under the app folder.
First, we store the supported languages in a variable, as follows:
SUPPORTED_LOCALES = [
    "en_US",
    "fr_FR",
]
2.	
Then, we start defining the resolve_accept_lanugage function, as follows:
from babel import Locale, negotiate_locale
def resolve_accept_language(
    accept_language: str = Header("en-US"),
) -> Locale:
3.	
Within the function, we parse the string into a list:
    client_locales = []
    for language_q in accept_language.split(","):
        if ";q=" in language_q:
            language, q = language_q.split(";q=")
        else:
            language, q = (language_q, float("inf"))
        try:
            Locale.parse(language, sep="-")
            client_locales
Advanced Features and Best Practices
214
5.	
Then, we use negotiate_locale from the babel package to get the most suited language:
    locale = negotiate_locale(
        [str(locale) for locale in locales],
        SUPPORTED_LOCALES,
    )
6.	
If there is no match, we return en_US as default:
    if locale is None:
        locale = "en_US"
    return locale
The resolve_accept_language function will be used as a dependency for the endpoints 
that return content based on the language.
7.	
In the same internationalization.py module, let’s create a GET /homepage 
endpoint that returns a welcome string, depending on the language. We will do it in a separate 
APIRouter, so the router will be as follows:
from fastapi import APIRouter
router = APIRouter(
    tags=["Localizad Content Endpoints"]
)
The tags parameter specifies that the router’s endpoint will be grouped separately in the 
interactive documentation under a specified tag name.
The GET /home endpoint will be as follows:
home_page_co
Internationalization and localization
215
In the example, the content has been hardcoded as a dict object with language code as a 
dictionary key.
In a real-world scenario, the content should be stored in a database for each language.
Similarly, you define a localization strategy to retrieve the currency.
8.	
Let’s create a GET /show/currency endpoint as an example that uses a dependency to 
retrieve the currency from the Accept-Language header. The dependency function 
can be defined as follows:
async def get_currency(
    language: Annotated[
        resolve_accept_language, Depends()
    ],
):
    currencies = {
        "en_US": "USD",
        "fr_FR": "EUR",
    }
    return currencies[language]
The endpoint will then be as follows:
from babel.numbers import get_currency_name
@router.get("/show/currency")
async def show_currency(
    currency: Annotated[get_currency, Depends()],
    language: Annotated[
        resolve_accept_language,
        Depends(use_cache=True)
    ],
):
    
Advanced Features and Best Practices
216
9.	
To use both endpoints, we will need to add the router to the FastAPI object in main.py:
from app import internationalization
# rest of the code
app.include_router(internationalization.router)
This is all you need to implement internationalization and localization. To test it, spin up the server 
from the command line by running:
$ uvicorn app.main:app
On the interactive documentation at http:localhost:8000/docs, you will find the 
GET /homepage and GET /show/currency endpoints. Both accept the Accept-Language 
header to provide the language choice; if you don’t, it will get the default language from the browser. 
To test the implementation, try experimenting with different values for the header.
You have successfully implemented internationalization and localization from scratch for your API. 
Using the recipe provided, you have integrated i18n and l10n into your applications, making them 
easily understandable worldwide.
See also
You can fi
Optimizing application performance
217
We will be using the pyinstrument package to set up a profiler for the application. If you haven’t 
installed the packages with requirements.txt, you can install pyinstrument in your 
environment by running the following:
$ pip install pyinstrument
Also, it can be useful to have a look at the Creating custom middleware recipe from earlier in the chapter.
How to do it…
Let's implement the profiler in simple steps.
1.	
Under the app folder, create a profiler.py module as follows:
from pyinstrument import Profiler
profiler = Profiler(
    interval=0.001, async_mode="enabled"
)
The async_mode="enabled" parameter specifies that the profiler logs the time each time 
it encounters an await statement in the function being awaited, rather than observing other 
coroutines or the event loop. The interval specifies the time between two samples.
2.	
Before using the profiler, we should plan what we want to profile. Let’s plan to profile only the 
code executed
Advanced Features and Best Practices
218
                os.getcwd() + "/profiler.html"
            )
            profiler.start()
        return response
The profiler is initiated every time an endpoint is requested, and it is terminated after the 
request is complete. However, since the server operates asynchronously, there is a possibility 
that the profiler may already be running, due to another endpoint request. This can result in 
errors during the start and stop of the profiler. To prevent this, we verify before each request 
whether the profiler is not already running. After the request, we check whether the profiler 
is running before terminating it.
3.	
You can attach the profiler to the FastAPI server by adding the middleware in the main.py 
module, as we did in the Creating custom middleware recipe:
app.add_middleware(ProfileEndpointsMiddleWare)
To test the profiler, spin up the server by running uvicorn app.main:app. Once 
you start making some calls, you can do it from th
Implementing rate limiting
219
Other techniques are related to external libraries or tools, and whatever strategy you use, make sure 
to properly validate it with proper profiling configuration.
Also, for high-traffic testing, take a look at the Performance testing for high traffic applications recipe 
in Chapter 5, Testing and Debugging FastAPI Applications.
Exercise
We learned how to configure middleware to profile applications; however, it is more common 
to create tests to profile specific use cases. We learned how to configure middleware to profile 
applications; however, it is more common to create test scripts to profile specific use cases. 
Try to create one by yourself that attaches the profiler to the server, runs the server, makes 
API calls that reproduce the use case, and finally, writes the profiler output. The solution is 
provided on the GitHub repository in the profiling_application.py file. You can 
find it at https://github.com/PacktPublishing/FastAPI-Cookbook/blob/

Advanced Features and Best Practices
220
Getting ready
To follow the recipe, you need a running FastAPI application with some endpoints to use for rate 
limiting. To implement rate limiting, we will use the slowapi package; if you haven’t installed the 
packages with the requirements.txt file provided in the GitHub repository, you can install 
slowapi in your environment with pip by running the following:
$ pip install slowapi
Once the installation is completed, you are ready to start the recipe.
How to do it…
We will start by applying a rate limiter to a single endpoint in simple steps.
1.	
Let’s create the rate_limiter.py module under the app folder that contains our limiter 
object class defined as follows:
from slowapi import Limiter
from slowapi.util import get_remote_address
limiter = Limiter(
    key_func=get_remote_address,
)
The limiter is designed to restrict the number of requests from a client based on their IP 
address. It is possible to create a function that can detect a
Implementing rate limiting
221
3.	
Now, we will apply a rate limit of two requests per minute to the GET /homepage endpoint 
defined in the internalization.py module:
from fastapi import Request
from app.rate_limiter import limiter
@router.get("/homepage")
@limiter.limit("2/minute")
async def home(
    request: Request,
    language: Annotated[
        resolve_accept_language, Depends()
    ],
):
    return {"message": home_page_content[language]}
The rate limit is applied as a decorator. Also, the request parameter needs to be added to make 
the limiter work.
Now, spin up the server from the command line by running the following:
$ uvicorn app.main:app
Then, try to make three consecutive calls to http://localhost:8000/homepage; you will get 
the home page content, and by the third call, you will get a 429 response with the following content:
{
    "error": "Rate limit exceeded: 2 per 1 minute"
}
You’ve just added a limit rate to the GET /homepage endpoint. With the same strategy, you 
Advanced Features and Best Practices
222
    RateLimitExceeded, _rate_limit_exceeded_handler
)
app.add_middleware(SlowAPIMiddleware)
Then, you simply need to specify the default limit in the Limiter object instantiation in the 
rate_limiter.py module:
limiter = Limiter(
    key_func=get_remote_address,
    default_limits=["5/minute"],
)
And that’s it. Now, if you rerun the server and call any of the endpoints more than five times consecutively, 
you will get a 429 response.
You have successfully set up a global rate limiter for your FastAPI application.
See also
You can find more on Slowapi features such as shared limits, limiting policies, and more in the official 
documentation at this link:
•	 SlowApi documentation: https://slowapi.readthedocs.io/en/latest/
You can check out more on the syntax of rate limit notation in the Limits project documentation at 
this link:
•	 Rate limit string notation: https://limits.readthedocs.io/en/stable/
quickstart.html#rate-limit-string-notation
Imp
Implementing background tasks
223
Getting ready
To follow this recipe, all you need is a FastAPI application running with at least one endpoint to apply 
the background task. However, we will implement the background task into our trip platform into the 
GET /v2/trips/{category} endpoint, defined in the Implementing dependency injection recipe.
How to do it…
Let’s imagine we want to store the message of the GET /v2/trips/{category} endpoint in an 
external database for analytics purposes. Let's do it in two simple steps.
1.	
First, we define a function that mocks the storing operation in a dedicated module, 
background_tasks.py, in the app folder. The function will look like the following:
import asyncio
import logging
logger = logging.getLogger("uvicorn.error")
async def store_query_to_external_db(message: str):
    logger.info(f"Storing message '{message}'.")
    await asyncio.sleep(2)
    logger.info(f"Message '{message}' stored!")
The storing operation is mocked by an asyncio.sleep
Advanced Features and Best Practices
224
            "\n. The coupon code is valid! "
            "You will get a discount!"
        )
    background_tasks.add_task(
        store_query_to_external_db, message
    )
    logger.info(
        "Query sent to background task, "
        "end of request."
    )
    return message
Now, if you spin up the server with uvicorn app.main:app and try to call the GET /v2/
trips/cruises endpoint, you will see the logs from the store_query_to_external_db 
function on the terminal output:
INFO:  Query sent to background task, end of request.
INFO:  127.0.0.1:58544 - "GET /v2/trips/cruises
INFO:  Storing message 'You requested Cruises trips.'
INFO:  Message 'You requested Cruises trips.' Stored!
That is all you need to implement background tasks in FastAPI! However, if you have to perform 
extensive background computations, you might want to use dedicated tools to handle queued task 
execution. This would allow you to run the tasks in a separate process
9
Working with WebSocket
Real-time communication has become increasingly important in modern web applications, enabling 
interactive features such as chat, notifications, and live updates. In this chapter, we’ll explore the 
exciting world of WebSockets and how to leverage them effectively in FastAPI applications. From 
setting up WebSocket connections to implementing advanced features such as chat functionality 
and error handling, this chapter provides a comprehensive guide to building responsive, real-time 
communication features. By the end of the chapter, you will have the skills to create WebSockets and 
facilitate real-time communication in FastAPI applications, enabling interactive functionalities and 
dynamic user experiences.
In this chapter, we’re going to cover the following recipes:
•	 Setting up Websockets in FastAPI
•	 Sending and receiving messages over WebSockets
•	 Handling WebSocket connections and disconnections
•	 Handling WebSocket errors and exceptions
•	 Impleme
Working with WebSocket
226
The code used in the chapter is hosted on GitHub at https://github.com/PacktPublishing/
FastAPI-Cookbook/tree/main/Chapter09.
It is recommended to set up a virtual environment for the project in the project root folder to efficiently 
manage dependencies and maintain project isolation.
Within your virtual environment, you can install all the dependencies at once by using the 
requirements.txt file provided in the GitHub repository in the project folder:
$ pip install –r requirements.txt
Since the interactive Swagger documentation is limited at the time of writing, basic mastering of 
Postman or any other testing API is beneficial to test our API.
Having basic knowledge of how WebSockets work can be beneficial, although it’s not necessary since 
the recipes will guide you through.
For the Implementing chat functionality with WebSockets recipe, we will write some basic HTML, 
including some Javascript code.
Setting up WebSockets in FastAPI
WebSockets provide a 
Setting up WebSockets in FastAPI
227
How to do it…
Create the project root folder called chat_platform. we can create our app folder containing the 
main.py module. Let's build our simple application with a WebSocket endpoint as follows.
1.	
We can start by creating our server in the main.py module:
from fastapi import FastAPI
app = FastAPI()
2.	
Then we can create the WebSocket endpoint to connect the client to the chat room:
from fastapi import WebSocket
@app.websocket("/ws")
async def ws_endpoint(websocket: WebSocket):
    await websocket.accept()
    await websocket.send_text(
        "Welcome to the chat room!"
    )
    await websocket.close()
The endpoint establishes the connection with the client, sends a welcome message, and closes 
the connection. This is the most basic configuration of a WebSocket endpoint.
That's it. To test it, spin up the server from the command line:
$ uvicorn app.main:app
Then open Postman and create a new WebSocket request. Specify the server URL as 
w
Working with WebSocket
228
The three events are listed in the Response panel of Postman.
Although not very useful from a practical point of view, this configuration is the bare minimum setup 
for a WebSocket connection. In the next recipe, we will see how to exchange messages between the 
client and the server through a WebSocket endpoint.
See also
You can check how to create a WebSocket endpoint on the FastAPI official documentation page:
•	 FastAPI WebSockets: https://fastapi.tiangolo.com/advanced/websockets/
At the time of writing, the Swagger documentation does not support WebSocket endpoints. If you 
spin up the server and open Swagger at http://localhost:8000/docs, you won’t see the 
endpoint we have just created. A discussion is ongoing on the FastAPI GitHub repository – you can 
follow it at the following URL:
•	 FastAPI WebSocket Endpoints Documentation Discussion: https://github.com/
tiangolo/fastapi/discussions/7713
Sending and receiving messages over WebSockets
WebSocket co
Sending and receiving messages over WebSockets
229
Now let’s modify the ws_endpoint function endpoint:
@app.websocket("/ws")
async def ws_endpoint(websocket: WebSocket):
    await websocket.accept()
    await websocket.send_text(
        "Welcome to the chat room!"
    )
    while True:
        data = await websocket.receive_text()
        logger.info(f"Message received: {data}")
        await websocket.send_text("Message received!")
You might have noticed that we have removed websocket.close() call from the previous recipe 
and used an infinite while loop. This allows the server side to continuously receive the message from 
the client and print it to the console without closing the connection. In this case, the connection can 
be closed only by the client.
This is all you need to read messages from the client and send it to the terminal output.
The server initiates a connection request when the client call the endpoint. With the 
websocket.receive_text() function, the server opens th
Working with WebSocket
230
3.	
You can then close the connection from the client by clicking on the Disconnect button to the 
right of the WebSocket URL field.
By enabling the server to receive messages from the client, you have just enabled bidirectional 
communication between the client and server through a WebSocket.
See also
The Fastapi.WebSocket instance is, in reality, a starlette.WebSocket class from the 
Starlette library. You can do more, such as validating messages as JSON or binary, by using the 
dedicated methods (the send_json or receive_json methods).
Check more on the official Starlette documentation page:
•	 Starlette Websockets: https://www.starlette.io/websockets/
Handling WebSocket connections and disconnections
When a client establishes a WebSocket connection with a FastAPI server, it’s crucial to handle the 
lifecycle of these connections appropriately. This includes accepting incoming connections, maintaining 
active connections, and handling disconnections gracef
Handling WebSocket connections and disconnections
231
Client-side disconnection
You might have noticed in the Sending and receiving messages over WebSockets recipe that if the connection 
is closed from the client (e.g., from Postman) on the server console, a WebSocketDisconnect 
exception propagates, uncaptured.
This is because the disconnection from the client side should be properly handled in a try-except block.
Let’s adjust the endpoint to take this into account. In the main.py module, we modify the /ws 
endpoint as follows:
from fastapi.websockets import WebSocketDisconnect
@app.websocket("/ws")
async def ws_endpoint(websocket: WebSocket):
    await websocket.accept()
    await websocket.send_text(
        "Welcome to the chat room!"
    )
    try:
        while True:
            data = await websocket.receive_text()
            logger.info(f"Message received: {data}")
    except WebSocketDisconnect:
        logger.warning(
            "Connection closed by the client"
        )

Working with WebSocket
232
    while True:
        data = await websocket.receive_text()
        logger.info(f"Message received: {data}")
        if data == "disconnect":
            logger.warn("Disconnecting...")
            await websocket.close()
            break
All we need is the checking condition of the data string content to then call the websocket.
close method and exit the while loop.
If you run the server, try to connect to the WebSocket /ws endpoint, and send the "disconnect" 
string as a message, the connection will be closed by the server.
You have seen how to manage disconnection and connection handshakes for a WebSocket endpoint, 
however, we still need to manage the right status code and messages for each. Let’s check this in the 
following recipe.
Handling WebSocket errors and exceptions
WebSocket connections are susceptible to various errors and exceptions that can occur during the 
lifecycle of a connection. Common issues include connection failures, message parsi
Handling WebSocket errors and exceptions
233
async def chatroom(websocket: WebSocket):
    if not websocket.headers.get("Authorization"):
        return await websocket.close()
    await websocket.accept()
    await websocket.send_text(
        "Welcome to the chat room!"
    )
    try:
        while True:
            data = await websocket.receive_text()
            logger.info(f"Message received: {data}")
            if data == "disconnect":
                logger.warn("Disconnecting...")
                return await websocket.close(
                    code=status.WS_1000_NORMAL_CLOSURE,
                    reason="Disconnecting...",
                )
    except WebSocketDisconnect:
        logger.warn("Connection closed by the client")
We have specified to the websocket.close method a status code and reason that will be transmitted 
to the client.
If we now spin up the server and send the disconnect message from the client, you will see a disconnection 
log message in the response 
Working with WebSocket
234
    await websocket.send_text(
        "Welcome to the chat room!"
    )
    try:
        while True:
            data = await websocket.receive_text()
            logger.info(f"Message received: {data}")
            if data == "disconnect":
                logger.warn("Disconnecting...")
                return await websocket.close(
                    code=status.WS_1000_NORMAL_CLOSURE,
                    reason="Disconnecting...",
                )
            if "bad message" in data:
                raise WebSocketException(
                    code=status.WS_1008_POLICY_VIOLATION,
                    reason="Inappropriate message"
                )
    except WebSocketDisconnect:
        logger.warn("Connection closed by the client")
If you spin up the server and try to send whatever message contains the "bad message" string, 
the client will be disconnected. Furthermore, on the Response panel section of Postman of your 
WebSocket connection you will s
Implementing chat functionality with WebSockets
235
You can also find a list of the compatibility of WebSocket events for browsers on the following page:
•	 WebSocket CloseEvent: https://developer.mozilla.org/en-US/docs/Web/
API/CloseEvent
Furthermore, the WebSocketException class in FastAPI is documented at the official 
documentation link:
•	 FastAPI WebSocketExcpetion API documentation: https://fastapi.tiangolo.com/
reference/exceptions/#fastapi.WebSocketException
Implementing chat functionality with WebSockets
Real-time chat functionality is a common feature in many modern web applications, enabling users to 
communicate instantly with each other. In this recipe, we’ll explore how to implement chat functionality 
using WebSockets in FastAPI applications.
By leveraging WebSockets, we will create a bidirectional communication channel between the server 
and multiple clients, allowing messages to be sent and received in real time.
Getting ready
To follow the recipe, you need to have a
Working with WebSocket
236
How to do it…
To build the application, we will need to build three core pieces – the WebSocket connections manager, 
the WebSocket endpoint, and the chat HTML page:
1.	
Let’s start by building the connection manager. The role of the connection manager is to keep 
track of open WebSocket connections and broadcast messages to active ones. Let’s define the 
ConnectionManager class in a dedicated ws_manager.py module under the app folder:
import asyncio
from fastapi import WebSocket
class ConnectionManager:
    def __init__(self):
        self.active_connections: list[WebSocket] = []
    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)
    async def send_personal_message(
        self, message: dict, websocket: WebSocket
    ):
        await websocket.send_json(message)
    async def br
Implementing chat functionality with WebSockets
237
The connection manager will then be used in the chat WebSocket endpoint.
2.	
Let’s create the WebSocket endpoint in a separate module called chat.py. Let’s initialize the 
connection manager:
from app.ws_manager import ConnectionManager
conn_manager = ConnectionManager()
Then we define the router:
from fastapi import APIRouter
router = APIRouter()
And finally, we can define the WebSocket endpoint:
from fastapi import WebSocket, WebSocketDisconnect
@router.websocket("/chatroom/{username}")
async def chatroom_endpoint(
    websocket: WebSocket, username: str
):
    await conn_manager.connect(websocket)
    await conn_manager.broadcast(
        f"{username} joined the chat",
        exclude=websocket,
    )
    try:
        while True:
            data = await websocket.receive_text()
            await conn_manager.broadcast(
                {"sender": username, "message": data},
                exclude=websocket,
            )
         
Working with WebSocket
238
            }
        )
3.	
After a new client joins a chat, the connection manager sends a message to all chat participants 
to notify them of the new arrival. The endpoint uses the username path parameter to retrieve 
the client’s name. Don’t forget to add the router to the FastAPI object in the main.py file:
from app.chat import router as chat_router
# rest of the code
app = FastAPI()
app.include_router(chat_router)
Once the WebSocket endpoint is ready, we can create the endpoint to return the HTML chat page.
4.	
The page endpoint will return an HTML page rendered with Jinja2.
The HTML chat page named chatroom.html should be stored in a templates folder in 
the project root. We will keep the page simple with the JavaScript tag embedded.
The HTML part will look like this:
<!doctype html>
<html>
  <head>
    <title>Chat</title>
  </head>
  <body>
    <h1>WebSocket Chat</h1>
    <h2>Your ID: <span id="ws-id"></span></h2>
    <form action="" onsubmit="sendMess
Implementing chat functionality with WebSockets
239
The <script> tag will contain the Javascript code that will connect to the WebSocket /
chatroom/{username} endpoint with the client name as a parameter, send the message 
from the client page, receive messages from the server, and render the message text on the page 
in the messages list section.
You can find an example in the GitHub repository, in the templates/chatroom.html 
file. Feel free to make your own version or download it.
5.	
To conclude, we need to build the endpoint that returns the HTML page. We can build it in 
the same chat.py module:
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from app.ws_manager import ConnectionManager
conn_manager = ConnectionManager()
templates = Jinja2Templates(directory="templates")
@router.get("/chatroom/{username}")
async def chatroom_page_endpoint(
    request: Request, username: str
) -> HTMLResponse:
    return templates.TemplateResponse(
      
Working with WebSocket
240
The endpoint will then use the ConnectionManager() connection manager object to exchange 
messages between all clients through the HTML page.
See also
We have used a basic feature of the Jinja2 templating library. However, you can free your creativity 
and discover the potential of this package by looking at the documentation:
•	 Jinja2 Documentation: https://jinja.palletsprojects.com/en/3.1.x/
Optimizing WebSocket performance
WebSocket connections provide a powerful mechanism for real-time communication between 
clients and servers. To ensure the optimal performance and scalability of WebSocket applications, it’s 
essential to implement effective optimization techniques and a way to measure them. In this recipe, 
we will see how to benchmark WebSocket endpoints to test the number of connections supported 
by the connection and suggest practical tips and techniques to optimize WebSocket performance in 
your FastAPI applications.
Getting ready
Besides knowledg
Optimizing WebSocket performance
241
    try:
        while True:
            data = await websocket.receive_text()
            await conn_manager.broadcast(
                # method's parameters
            )
            await conn_manager.send_personal_message(
                # method's parameters
            )
            logger.info(
                f"{username} says: {data}"
            )
    except WebSocketDisconnect:
        conn_manager.disconnect(websocket)
        await conn_manager.broadcast(
            # method's paramters
        )
        logger.info(f"{username} left the chat")
We are now ready to create a benchmark script to test our chat functionality.
How to do it…
Let’s create the script file under the root folder and call it benchmark_websocket.py. A typical 
benchmark script should do the following tasks:
•	 Define a function to run the FastAPI server
•	 Define another function to connect n number of clients of the WebSocket endpoint and exchange 
a certain numb
Working with WebSocket
242
The run_server function is an alternative to the command-line uvicorn app.main:app 
command we are used to running from the terminal.
2.	
Now let’s define a function that will create a certain number of clients that will connect to the 
WebSocket endpoint and exchange some messages:
import asyncio
from websockets import connect
async def connect_client(
    n: int, n_messages: int = 3
):
    async with connect(
        f"ws://localhost:8000/chatroom/user{n}",
    ) as client:
        for _ in range(n_messages):
            await client.send(
                f"Hello World from user{n}"
            )
            await asyncio.sleep(n * 0.1)
        await asyncio.sleep(2)
 To simulate concurrent connection patterns, we use an async def function. This will 
enable us to evaluate the server’s performance under the high load of simultaneous requests 
to the endpoint.
Furthermore, we added some asynchronous sleeping time (asyncio.sleep) between 
messages to simulate
Optimizing WebSocket performance
243
    await asyncio.sleep(1)
    p.terminate()
The function creates a process to spin up the server, start it, wait some time to finish the startup, 
and simultaneously run all the clients to call the server.
4.	
Finally, to make it run, we need to pass it to the event loop if it is run as a script. We can do 
it like this:
if __name__ == "__main__":
    asyncio.run(main())
To run the script, simply run it as a Python script from the command line:
$ python benchmark_websocket.py
If you leave the default value for the parameter n_clients, you will probably see all the messages 
flowing on the terminal. However, by increasing n_clients, depending on your machine, at some 
point, the script will not be able to run anymore and you will see socket connection errors popping 
up. That means that you passed the limit to support new connections with your endpoint.
What we did is the core of a basic script to benchmark. You can further expand the script based o
Working with WebSocket
244
See also
You can see more on unit testing WebSockets with FastAPI in the official documentation:
•	 Testing WebSockets in FastAPI: https://fastapi.tiangolo.com/advanced/
testing-websockets/
Securing WebSocket connections with OAuth2
Securing WebSocket connections is paramount to safeguarding the privacy and security of user 
interactions in real-time applications. By implementing authentication and access control mechanisms, 
developers can mitigate risks associated with unauthorized access, eavesdropping, and data tampering. 
In this recipe, we will see how to create a secure WebSocket connection endpoint with OAuth2 token 
authorization in your FastAPI applications.
Getting ready
To follow the recipe, you should already know how to set up a basic WebSocket endpoint – explained 
in the Setting up WebSockets in FastAPI recipe in this chapter.
Furthermore, we are going to use OAuth2 with a password and a bearer token. We will apply the same 
strategy we used t
Securing WebSocket connections with OAuth2
245
How to do it…
At the time of writing, there is no support for the OAuth2PasswordBearer class for WebSocket 
in FastAPI. This means that checking the bearer token in the headers for WebSocket is not as 
straightforward as it is for HTTP calls. However, we can create a WebSocket-specific class that is 
derived from the one used by HTTP to achieve the same functionality as follows.
1.	
Let’s do it in a dedicated module under the app folder called ws_password_bearer.py:
from fastapi import (
    WebSocket,
    WebSocketException,
    status,
)
from fastapi.security import OAuth2PasswordBearer
class OAuth2WebSocketPasswordBearer(
    OAuth2PasswordBearer
):
    async def __call__(
        self, websocket: WebSocket
    ) -> str:
        authorization: str = websocket.headers.get(
            "authorization"
        )
        if not authorization:
            raise WebSocketException(
                code=status.HTTP_401_UNAUTHORIZED,
          
Working with WebSocket
246
2.	
Let’s define the oauth2_scheme_for_ws object:
from app.ws_password_bearer import (
    OAuth2WebSocketPasswordBearer,
)
oauth2_scheme_for_ws = OAuth2WebSocketPasswordBearer(
    tokenUrl="/token"
)
3.	
The tokenUrl argument specifies the callback endpoint to call to retrieve the token. This 
endpoint should be built according to the token resolution you use. After that, we can create 
a function that retrieves the username from the token:
def get_username_from_token(
    token: str = Depends(oauth2_scheme_for_ws),
) -> str:
    user = fake_token_resolver(token)
    if not user:
        raise WebSocketException(
            code=status.HTTP_401_UNAUTHORIZED,
            reason=(
                "Invalid authentication credentials"
            )
        )
    return user.username
The purpose of the fake_token_resolver function is to simulate the process of resolving 
a token. This function can be found in the security.py file in the GitHub repository of the
Securing WebSocket connections with OAuth2
247
4.	
Now let’s use it to secure our WebSocket endpoint, /secured-ws, in the main.py module:
from import Annotated
from fastapi import Depends
from app.security import get_username_from_token
@app.websocket("/secured-ws")
async def secured_websocket(
    websocket: WebSocket,
    username: Annotated[
        get_username_from_token, Depends()
    ]
):
    # rest of the endpoint
This is all you need to build a secured WebSocket endpoint.
To test it, spin up the server from the terminal by running the following:
$ uvicorn app.main:app
When attempting to connect to the WebSocket endpoint using Postman or another tool to the address 
ws://localhost:8000/secured-ws, an authorization error will occur, and the connection 
will be rejected before the handshake.
To allow the connection, we need to retrieve the token and pass it through the headers of the WebSocket 
request in Postman. You can retrieve the token from the dedicated endpoint or, if you 
Working with WebSocket
248
Exercise
Try to build a secure chat functionality where users need to log in to participate in the chat.
Tips: The endpoint that returns the HTML page should check for the bearer token in the 
cookies. If the cookie is not found or the bearer token is not valid, it should redirect the client 
to a login page that puts the token in the browser’s cookies.
You can use the response.RedirectResponse class from the fastapi package 
to handle redirections. The usage is quite straightforward and you can have a look at the 
documentation page at the link:
h t t p s : / / f a s t a p i . t i a n g o l o . c o m / a d v a n c e d / c u s t o m -
response/#redirectresponse.
See also
Integrating OAuth2 into WebSockets in FastAPI with an OAuth2PasswordBearer-like class is 
a current topic of interest, and it is expected to evolve quickly over time. You can follow the ongoing 
discussion in the FastAPI GitHub repository:
•	 OAuth2PasswordBearer with WebSocket Discussion: ht
10
Integrating FastAPI with 
other Python Libraries
In this chapter, we will delve into the process of expanding the capabilities of FastAPI by integrating it 
with other Python libraries. By harnessing the power of external tools and libraries, you can enhance 
the functionality of your FastAPI applications and unlock new possibilities for creating dynamic and 
feature-rich web services.
Throughout this chapter, you will learn how to integrate FastAPI with a diverse range of Python 
libraries, each serving a different purpose and offering unique functionalities. From taking advantage 
of advanced natural language processing capabilities with Cohere and LangChain to integrating 
real-time communication features with gRPC and GraphQL, you will discover how to harness the 
full potential of FastAPI in conjunction with other popular Python tools.
By integrating FastAPI with other Python libraries, you will be able to build sophisticated web 
applications that go beyond simple REST APIs. W
Integrating FastAPI with other Python Libraries
250
Technical requirements
To follow the recipes in this chapter, it is important to have a good understanding of FastAPI. 
Additionally, since this chapter demonstrates how to integrate FastAPI with external libraries, having 
a basic knowledge of each library can be beneficial.
However, we will provide external links for you to review any of the concepts that are used in the recipes. 
You can also refer back to this chapter whenever you need to integrate a technology with FastAPI.
The code used in the chapter is hosted on GitHub at https://github.com/PacktPublishing/
FastAPI-Cookbook/tree/main/Chapter10.
It is recommended to set up a virtual environment for the project in the project root folder to efficiently 
manage dependencies and maintain project isolation.
For each recipe, you can install all the dependencies at once within your virtual environment by using 
the requirements.txt file provided in the GitHub repository in the follow
Integrating FastAPI with gRPC
251
Before starting with the recipe, let’s build a basic gRPC server with one method that takes a message 
from the client and sends back a message as well by following these steps.
1.	
Under the root project let’s create a grpcserver.proto file containing the definition of 
our server as follows:
syntax = "proto3";
service GrpcServer{
    rpc GetServerResponse(Message)
    returns (MessageResponse) {}
}
2.	
In the same file, we will define the Message and MessageResponse messages as follows:
message Message{
string message = 1;
}
message MessageResponse{
string message = 1;
bool received = 2;
}
From the .proto file we have just created, we can automatically generate the Python code 
necessary to integrate the service and gRPC client as well with a proto compiler.
3.	
Then, from the command line terminal, run the following command:
$ python -m grpc_tools.protoc \
--proto_path=. ./grpcserver.proto \
--python_out=. \
--grpc_python_out=.
This command will gen
Integrating FastAPI with other Python Libraries
252
4.	
Now let’s write a script to run the gRPC server. Let’s create a file called grpc_server.py 
and define the server class as follows:
from grpcserver_pb2 import MessageResponse
from grpcserver_pb2_grpc import GrpcServerServicer
class Service(GrpcServerServicer):
    async def GetServerResponse(
        self, request, context
    ):
        message = request.message
        logging.info(f"Received message: {message}")
        result = (
            "Hello I am up and running, received: "
            f"{message}"
        )
        result = {
            "message": result,
            "received": True,
        }
        return MessageResponse(**result)
5.	
Then we will define the function to run the server on the localhost on port 50015 as follows:
import grpc
from grpcserver_pb2_grpc import (
    add_GrpcServerServicer_to_server
)
async def serve():
    server = grpc.aio.server()
    add_GrpcServerServicer_to_server(
        Service()
Integrating FastAPI with gRPC
253
6.	
We then close the script by running the serve function into the event loop:
import asyncio
import logging
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    asyncio.run(serve())
This is all we need to build the gRPC server. Now we can run the script from the command line:
$ python ./grpc_server.py
If everything has been set up correctly you will see the following log message on the terminal:
INFO:root:Starting server on port 50051
With the gRPC server running, we can now create our gateway by leveraging FastAPI.
How to do it…
We will create a FastAPI application with one GET /grpc endpoint that will take a message as a 
parameter, forward the request to the gRPC server, and return the message from the gRPC server to 
the client. Let’s go through the following steps to build a basic gateway application.
1.	
Under the project root folder, let’s create a folder called app with a main.py module containing 
the server as follows:
Integrating FastAPI with other Python Libraries
254
3.	
Then we will initialize the grpc_channelobject, which is an abstraction layer for gRPC calls 
containing the gRPC service URL, as follows:
grpc_channel = grpc.aio.insecure_channel(
    "localhost:50051"
)
4.	
Finally, we can create our endpoint as follows:
@app.get("/grpc")
async def call_grpc(message: str) -> GRPCResponse:
    async with grpc_channel as channel:
        grpc_stub = GrpcServerStub(channel)
        response = await grpc_stub.GetServerResponse(
            Message(message=message)
        )
        return response
Once we have created our FastAPI application, let’s spin up the server from the command line:
$ uvicorn app.main:app
Open the interactive documentation at http://localhost:8000/docs and you will see the 
new endpoint that will take a message parameter and return the response from the gRPC server. If 
you try to call it, you will also see the log message for the call on the gRPC server terminal.
You have su
Connecting FastAPI with GraphQL
255
See also
You can dive deeper into protocol buffer and how you can use it in Python code in the official 
documentation:
•	 Protocol Buffer Python Generated Code: https://protobuf.dev/reference/python/
python-generated/
You check more on how to implement gRPC in Python code at the gRPC official documentation page:
•	 gRPC Python Tutorial: https://grpc.io/docs/languages/python/basics/
Also, have a look at the examples on GitHub:
•	 gRPC Python GitHub Examples: https://github.com/grpc/grpc/tree/master/
examples/python
Connecting FastAPI with GraphQL
GraphQL is a query language for APIs and a runtime for executing queries. It provides an efficient, 
powerful, and flexible alternative to traditional REST APIs by allowing clients to specify exactly 
what data they need. Integrating FastAPI with GraphQL enables you to build APIs that are highly 
customizable and capable of handling complex data requirements. In this recipe, we will see how to 
connect FastA
Integrating FastAPI with other Python Libraries
256
How to do it…
Let’s create a basic GraphQL endpoint that retrieves users from a specific country in a database. Let’s 
do it through the following steps.
1.	
Let’s create a database.py module containing a list of users that we will use as a database 
source. Define the User class as follows:
from pydantic import BaseModel
class User(BaseModel):
    id: int
    username: str
    phone_number: str
    country: str
2.	
You can then write a users_db object, which will be a list of User class objects, or copy the 
one from the respective database.py file on the GitHub repository at https://raw.
githubusercontent.com/PacktPublishing/FastAPI-Cookbook/main/
Chapter10/graphql/database.py.
It will look like this:
users_db: list[User] = [
    User(
        id=1,
        username="user1",
        phone_number="1234567890",
        country="USA",
    ),
# other users
]
We will use this list as a database for our simple query.
3.	
In a separate mod
Connecting FastAPI with GraphQL
257
4.	
Then we will define the query as follows:
@strawberry.type
class Query:
    @strawberry.field
    def users(
        self, country: str | None
    ) -> list[User]:
        return [
            User(
                username=user.username,
                phone_number=user.phone_number,
                country=user.country,
            )
            for user in users_db
            if user.country == country
        ]
The query takes a country as an argument and returns all the users for the country.
5.	
Now, in the same file, let’s create the GraphQL schema with the FastAPI router:
from strawberry.fastapi import GraphQLRouter
schema = strawberry.Schema(Query)
graphql_app = GraphQLRouter(schema)
The last line will create a fastapi.Router instance that will handle the endpoint.
6.	
Let’s finalize the endpoint by adding the router to the main FastAPI instance in a separate 
main.py module as follows:
from fastapi import FastAPI
from graphql_utils im
Integrating FastAPI with other Python Libraries
258
Now let’s open the browser at http://localhost:8000/graphql. You will see an interactive 
page for the endpoint. The page is divided into two panels. The left contains the query editor and the 
right will show you the response.
Try to make the following GraphQL query:
{
  users(country: "USA") {
    username
    country
    phoneNumber
  }
}
You will see the result on the right panel, which will look something like this:
{
  "data": {
    "users": [
      {
        "username": "user1",
        "country": "USA",
        "phoneNumber": "1234567890"
      }
    ]
  }
}
You have learned how to create an interactive GraphQL endpoint. By combining RESTful endpoints 
with GraphQL, the potential for data querying and modification can be greatly expanded. Real-world 
scenarios may involve using REST endpoints to modify the database by adding, modifying, or removing 
records. GraphQL can then be used to query the database and extract valuable i
Using ML models with Joblib
259
Using ML models with Joblib
ML models are powerful tools for data analysis, prediction, and decision-making in various applications. 
FastAPI provides a robust framework for building web services, making it an ideal choice for deploying 
ML models in production environments. In this recipe, we will see how to integrate an ML model 
with FastAPI using Joblib, a popular library for model serialization and deserialization in Python.
We will develop an AI-powered doctor application that can diagnose diseases by analyzing the 
symptoms provided.
Warning
Note that the diagnoses provided by the AI doctor should not be trusted in real-life situations, 
as it is not reliable.
Getting ready
Prior knowledge of ML is not mandatory but having some can be useful to help you follow the recipe.
We will apply the recipe to a new project, so create a folder named ai_doctor that we will use as 
the project root folder.
To ensure that you have all the necessary packages in 
Integrating FastAPI with other Python Libraries
260
How to do it…
Let’s follow these steps to create our AI doctor:
1.	
Let’s start by writing the code to accommodate the ML model. In the project root folder, let's 
create the app folder containing a module called utils.py. In the module, we will declare a 
symptoms_list list containing all the symptoms accepted by the model. You can download 
the file directly from the GitHub repository at https://raw.githubusercontent.
com/PacktPublishing/FastAPI-Cookbook/main/Chapter10/ai_doctor/
app/utils.py.
You can find the complete list on the model’s documentation page at https://huggingface.
co/AWeirdDev/human-disease-prediction.
2.	
Still in the app folder, let’s create the main.py module that will contain the FastAPI server 
class object and the endpoint. To incorporate the model into our application, we will utilize 
the FastAPI lifespan feature.
We can define the lifespan context manager as follows:
from fastapi import FastAPI
from context
Using ML models with Joblib
261
3.	
Once it has been defined, we need to pass it to the FastAPI object class as follows:
app = FastAPI(
    title="AI Doctor",
    lifespan=lifespan
)
4.	
Now we need to create the endpoint that will take the symptoms as parameters and return 
the diagnosis.
The idea is to return each symptom as a path parameter. Since we have 132 possible symptoms, 
we will create the parameters object dynamically with Pydantic and restrict our model to the 
first ten symptoms. In the main.py file, let’s create the Symptoms class used to accept the 
parameters with the pydantic.create_model function as follows:
from pydantic import create_model
from app.utils import symptoms_list
query_parameters = {
    symp: (bool, False)
    for symp in symptoms_list[:10]
}
Symptoms = create_model(
    "Symptoms", **query_params
)
We now have all that we need to create our GET /diagnosis endpoint.
5.	
Let’s create our endpoint as follows:
@app.get("/diagnosis")
async def get_diagnosi
Integrating FastAPI with other Python Libraries
262
    diseases = ml_model["doctor"].predict([array])
    return {
        "diseases": [disease for disease in diseases]
    }
To test it, as usual, spin up the server with uvicorn from the command line by running the following:
$ uvicorn app.main:app
Open the interactive documentation from the browser at http://localhost:8000/docs. You 
will see the only GET /diagnosis endpoint and you will be able to select the symptoms. Try to 
select some of them and get your diagnosis from the AI doctor you have just created.
You have just created a FastAPI application that integrates an ML model. You can use the same model 
for different endpoints, but you can also integrate multiple models within the same application with 
the same strategy.
See also
You can check the guidelines on how to integrate an ML model into FastAPI on the official 
documentation page:
•	 Lifespan Events: https://fastapi.tiangolo.com/advanced/
events/?h=machine+learning#use
Integrating FastAPI with Cohere
263
By leveraging Cohere AI’s models, developers can empower their applications to engage in natural 
language conversations, answer queries, generate creative content, and perform a wide range of 
language-related tasks.
In this recipe, we will create an AI-powered chatbot using FastAPI and Cohere that suggests Italian 
cuisine recipes based on user queries.
Getting ready
Before starting the recipe, you will need a Cohere account and an API key.
You can create your account at the page https://dashboard.cohere.com/welcome/
login by clicking the Sign up button at the top. At the time of writing, you can create an account 
by using your existing GitHub or Google account.
Once logged in, you will see a welcome page and a platform menu on the left with some options. Click 
on API keys to access the API menu.
By default, you will have a trial key that is free of charge, but it is rate limited and it cannot be used 
for commercial purposes. For the recipe, it 
Integrating FastAPI with other Python Libraries
264
How to do it…
We will create our chef cuisine assistant by using a message completion chat. Chat completion models 
take a list of messages as input and return a model-generated message as output. The first message to 
provide is the system message.
A system message defines how a chatbot behaves in a conversation, such as adopting a specific tone 
or acting as a specialist such as a senior UX designer or software engineer. In our case, the system 
message will tell the chatbot to behave like a chef de cuisine.
Let’s create an endpoint to call our chat through the following steps:
1.	
Let’s create a handlers.py module under the project root and import the Cohere API key 
from the .env file:
from dotenv import load_dotenv
load_dotenv()
2.	
Let’s write the system message as follows:
SYSTEM_MESSAGE = (
    "You are a skilled Italian top chef "
    "expert in Italian cuisine tradition "
    "that suggest the best recipes unveiling "
    "t
Integrating FastAPI with Cohere
265
5.	
Then, we can define the function to generate our message:
async def generate_chat_completion(
    user_query=" ", messages=[]
) -> str:
    try:
        response = await client.chat(
            message=user_query,
            model="command-r-plus",
            preamble=SYSTEM_MESSAGE,
            chat_history=messages,
        )
        messages.extend(
            [
                ChatMessage(
                    role="USER", message=user_query
                ),
                ChatMessage(
                    role="CHATBOT",
                    message=response.text,
                ),
            ]
        )
        return response.text
    except ApiError as e:
        raise HTTPException(
            status_code=e.status_code, detail=e.body
        )
The function will take in input the user query and the messages previously exchanged during 
the conversation. If the response is returned with no errors, the messages list is updated with 

Integrating FastAPI with other Python Libraries
266
async def lifespan(app: FastAPI):
    yield {"messages": []}
7.	
We then pass the lifespan context manager to the app object as:
app = FastAPI(
    title="Chef Cuisine Chatbot App",
    lifespan=lifespan,
)
8.	
Finally, we can create our endpoint as follows:
from typing import Annotated
from fastapi import Body, Request
from handlers import generate_chat_completion
@app.post("/query")
async def query_chat_bot(
    request: Request,
    query: Annotated[str, Body(min_length=1)],
) -> str:
    answer = await generate_chat_completion(
        query, request.state.messages
    )
    return answer
We enforce a minimum length for the query message (Body(min_length=1)) to prevent 
the model from returning an error response.
You have just created an endpoint that interacts with our chef de cuisine chatbot.
To test it, spin up the server with uvicorn:
$ uvicorn main:app
Open the interactive documentation and start testing the endpoint. For exa
Integrating FastAPI with LangChain
267
Exercise
We have created a chatbot endpoint to interact with our assistant. However, for real-life 
applications, it can be useful to have an endpoint that returns all the messages exchanged.
Create a GET /messages endpoint that returns all the messages in a formatted way.
Also create an endpoint POST /restart-conversation that will flush all the messages 
and restart the conversation without any previous messages.
See also
You can have a look at the Cohere quickstart on building a chatbot on the official documentation page:
•	 Building a Chatbot: https://docs.cohere.com/docs/building-a-chatbot
In production environment, depending on the project’s needs and budget, you might want to choose 
from the several models available. You can see an overview of the models provided by Cohere here:
•	 Models Overview: https://docs.cohere.com/docs/models
Integrating FastAPI with LangChain
LangChain is a versatile interface for nearly any Large Language Model (
Integrating FastAPI with other Python Libraries
268
Aside from the fastapi and uvicorn packages, you will need to install python-dotenv and 
the packages related to LangChain. You can do this by using requirements.txt or by installing 
them with pip as follows:
$ pip install fastapi uvicorn python-dotenv
$ pip install langchain
$ pip install langchain-community langchain-cohere
$ pip install chromadb unstructured
Once the installation is complete, we can start building our AI shop assistant.
How to do it…
We are going to create an application with a single endpoint that interacts with an LLM from Cohere.
The idea behind LangChain is to provide a series of interconnected modules, forming a chain to 
establish a workflow linking the user query with the model output.
We will split the process of creating the endpoint to interact with the RAG AI assistant into the 
following steps:
1.	
Defining the prompts
2.	
Ingesting and vectorizing the documents
3.	
Building the model chain
4.	
Creatin
Integrating FastAPI with LangChain
269
    of the context below you are trained on.
    -----------
    {context}
    -----------
    if you don't know the answer,
    you will ask the user
    to rephrase the question or
    redirect the user the support@ecotech.com
    always be friendly and helpful
    at the end of the conversation,
    ask the user if they are satisfied
    with the answer if yes,
    say goodbye and end the conversation
    """
This is a common prompt for customer assistants that contains two variables: question and 
context. Those variables will be required to query the model.
2.	
With that template, we can define the system message as follows:
from langchain.prompts import (
    SystemMessagePromptTemplate,
)
system_message_prompt = (
    SystemMessagePromptTemplate.from_template(
        template
    )
)
3.	
The user message does not require specific context and can be defined as follows:
from langchain.prompts import (
    HumanMessagePromptTemplate,
)
human_
Integrating FastAPI with other Python Libraries
270
4.	
Then we can group both messages under the dedicated chat message template object as follows:
from langchain.prompts import ChatPromptTemplate
chat_prompt_template = (
    ChatPromptTemplate.from_messages(
        [system_message_prompt, human_message_prompt]
    )
)
This is all we need to set up the prompt object to query our model.
Ingesting and vectorizing the documents
Our assistant will answer user questions by analyzing the documents we will provide to the model. 
Let’s create a docs folder under the project root that will contain the documents. First, download the 
faq_ecotech.txt file from the GitHub repository in the ecotech_RAG/docs project folder 
and save it in the local docs folder.
You can download it directly at https://raw.githubusercontent.com/PacktPublishing/
FastAPI-Cookbook/main/Chapter10/ecotech_RAG/docs/faq_ecotech.txt.
Alternatively, you can create your own FAQ file. Just ensure that each question and answer 
Integrating FastAPI with LangChain
271
    db: Chroma,
):
    text_splitter = CharacterTextSplitter(
        chunk_size=100, chunk_overlap=0
    )
    raw_documents = DirectoryLoader(
        "docs", "*.txt"
    ).load()
    chunks = text_splitter.split_documents(
        raw_documents
    )
    await db.aadd_documents(chunks)
The DirectoryLoader class uploads the content of all the .txt files from the docs folder, then 
the text_splitter object reorganizes the documents into document chunks of 100 characters 
that will be then added to the Chroma database.
By utilizing the vectorized database alongside the user query, we can retrieve the relevant context to 
feed into our model, which will analyze the most significant portion.
We can write a function for this called get_context as follows:
def get_context(
    user_query: str, db: Chroma
) -> str:
    docs = db.similarity_search(user_query)
    return "\n\n".join(
        doc.page_content for doc in docs
    )
The documents have to be
Integrating FastAPI with other Python Libraries
272
Building the model chain
Once we have defined the mechanism to retrieve the context, we can build the chain model. Let’s 
build it through the following steps:
1.	
Let’s create a new module called model.py. Since we will use Cohere, we will upload the 
environment variables from the .env file with the dotenv package as follows:
from dotenv import load_dotenv
load_dotenv()
2.	
Then we will define the model we are going to use:
from langchain_cohere import ChatCohere
model = ChatCohere(model="command-r-plus")
We will use the same module we used in the previous recipe, Command R+.
3.	
Now we can gather the pieces we have created to leverage the power of LangChain by creating 
the chain pipeline to query the model as follows:
from langchain.schema import StrOutputParser
from prompting import chat_prompt_template
chain = (
    chat_prompt_template | model | StrOutputParser()
)
We will use the chain object to create our endpoint to expose t
Integrating FastAPI with LangChain
273
from documents import load_documents
@asynccontextmanager
async def lifespan(app: FastAPI):
    db = Chroma(
        embedding_function=CohereEmbeddings()
    )
    await load_documents(db)
    yield {"db": db}
2.	
We can then pass it to the FastAPI object as follows:
app = FastAPI(
    title="Ecotech AI Assistant",
    lifespan=lifespan
)
3.	
Now, we can define a POST /message endpoint as follows:
from typing import Annotated
from fastapi import Body, Request
from documents import get_context
from model import chain
@app.post("/message")
async def query_assistant(
    request: Request,
    question: Annotated[str, Body()],
) -> str:
    context = get_context(question, request.state.db)
    response = await chain.ainvoke(
        {
            "question": question,
            "context": context,
        }
    )
    return response
4.	
The endpoint will accept a body string text as input and will return the response from the model 
as a string bas
Integrating FastAPI with other Python Libraries
274
To test it, you can spin up the server from the following command:
$ uvicorn main:app
Once the server has started, open the interactive documentation at http://localhost:8000/docs 
and you will see the POST /message endpoint we just created.
Try first to send a message that is not related to the assistance, something like the following:
"What is the capital of Belgium ?"
You will receive an answer like this:
"I apologize, but I cannot answer that question as it is outside of 
my knowledge base. I am an FAQ chatbot trained to answer specific 
questions related to EcoTech Electronics, including our product 
compatibility with smart home systems, international shipping costs, 
and promotions for first-time customers. If you have any questions 
related to these topics, I'd be happy to help! Otherwise, for general 
inquiries, you can reach out to our support team at support@ecotech.
com. Is there anything else I can assist you with today r
Integrating FastAPI with LangChain
275
Exercise
We have implemented the endpoint to interact with the chat model that will answer based on 
the document provided. However, real-life API applications will allow the addition of new 
documents interactively.
Create a new POST /document endpoint that will add a file in the docs folder and reload 
the documents in the code.
Have a look at the Working with file uploads and downloads recipe in Chapter 2, Working with 
Data, to see how to upload files in FastAPI.
See also
You can have a look at the quickstart in the LangChain documentation:
•	 LangChain Quickstart: https://python.langchain.com/v0.1/docs/get_
started/quickstart/
We have used Chroma, a vector database largely used for ML applications. Feel free to have a look at 
the documentation:
•	 Chroma: https://docs.trychroma.com/

11
Middleware and Webhooks
In this chapter, we delve into the advanced and crucial aspects of middleware and webhooks in 
FastAPI. Middleware in FastAPI allows you to process requests and responses globally before they 
reach your route handlers and after they leave them. Webhooks, on the other hand, enable your FastAPI 
application to communicate with other services by sending real-time data updates. Both middleware 
and webhooks are essential for building robust, efficient, and scalable applications.
We will start by exploring how to create custom Asynchronous Server Gateway Interface (ASGI) 
middleware from scratch. This will give you a deep understanding of how middleware works at a 
fundamental level.
Next, we’ll develop middleware specifically for response modification, allowing you to intercept and 
alter responses before they are sent back to the client.
We will also cover handling Cross-Origin Resource Sharing (CORS) with middleware. This is 
particularly important for applica
Middleware and Webhooks
278
Technical requirements
At this stage of the book, you should already have a good understanding of the basics of FastAPI, how 
to install it, and how to run it.
The code used in the chapter is hosted on GitHub at the following address: https://github.
com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter11.
It is recommended to set up a virtual environment for the project in the project root folder to efficiently 
manage dependencies and maintain project isolation.
Throughout the chapter, we will only be using the standard fastapi library with uvicorn. You 
can install all the dependencies within your virtual environment using pip from the command line 
by running the following:
$ pip install fastapi uvicorn
For the Handling CORS with middleware recipe, having some basic knowledge of JavaScript and 
HTML will be beneficial.
Creating custom ASGI middleware
ASGI is a specification for Python web servers and applications to communicate with each other, 
designe
Creating custom ASGI middleware
279
How to do it…
Let’s start by creating a project root folder called middleware_project. Under the root folder, 
create a folder called middleware containing a module called asgi_middleware.py. Let’s start 
the module by declaring the logger that we will use during the middleware call:
import logging
logger = logging.getLogger("uvicorn")
Then we can define the middleware class as follows:
from starlette.types import (
    ASGIApp, Scope, Receive, Send
)
class ASGIMiddleware:
    def __init__(
        self, app: ASGIApp, parameter: str = "default"
):
        self.app = app
        self.parameter = parameter
    async def __call__(
        self,
        scope: Scope,
        receive: Receive,
        send: Send,
    ):
        logger.info("Entering ASGI middleware")
        logger.info(
            f"The parameter is: {self.parameter}"
        )
        await self.app(scope, receive, send)
        logger.info("Exiting ASGI middleware")
Then, we need to i
Middleware and Webhooks
280
    title="Middleware Application",
    middleware=[
        Middleware(
            ASGIMiddleware,
            parameter="example_parameter",
        ),
    ]
)
This is all you need to implement custom ASGI middleware in a FastAPI application.
How it works…
To see the middleware in action, let’s create a general endpoint in main.py module, as in the 
following example:
@app.get("/")
async def read_root():
    return {"Hello": "Middleware World"}
Spin up the server by running uvicorn main:app from the command line. You will see the 
following messages:
INFO:    Started server process [2064]
INFO:    Waiting for application startup.
INFO:    Entering ASGI middleware
INFO:    The parameter is: example_parameter
Among the messages, you will notice those indicating that we have already entered the middleware. Now 
try to call the root endpoint. You can do it by opening the browser at http://localhost:8000/.
Still on the terminal, this time you will notice both 
Creating custom ASGI middleware
281
Information on the event type within the middleware is stored in the scope parameter of the __
call__ method. Let’s include the following logs in the ASGIMiddleware.__call__ method 
to improve our understanding of the mechanism:
class ASGIMiddleware:
    def __init__(
        self,
        app: ASGIApp,
        parameter: str = "default",
    ):
    # method content
    async def __call__(
        self,
        scope: Scope,
        receive: Receive,
        send: Send,
    ):
        # previous logs
        logger.info(
            f"event scope: {scope.get('type')}"
        )
        await self.app(scope, receive, send)
If you restart the server and remake the call to http://localhost:8000/, you will now see 
the log messages specifying the event scope type to be lifespan at the server startup and http 
after the endpoint call.
There’s more…
We have just seen how to build ASGI middleware as a class. However, you can also do it by leveraging 
the fu
Middleware and Webhooks
282
            f"The parameter you proved is: {parameter}"
        )
        logger.info(
            f"event scope: {scope.get('type')}"
        )
        await app(scope, receive, send)
        logger.info("Exiting second ASGI middleware")
    return wrapped_app
This is the equivalent of the ASGIMiddleware class defined earlier in the How to do it… subsection. 
To make it work, it should be passed as an argument to the FastAPI instance in exactly the same way:
from middleware.asgi_middleware import asgi_middleware
app = FastAPI(
    title="Middleware Application",
    middleware=[
        Middleware(
            asgi_middleware,
            parameter="example_parameter",
        ),
    ]
Based on your personal preference, you can choose the style you prefer. However, for the rest of the 
chapter, we will continue using the middleware class style.
See also
You can read more on the ASGI specification in the dedicated documentation page:
•	 ASGI Documentation: h
Developing middleware for request modification
283
In this recipe, we’ll focus on developing custom ASGI middleware to modify responses before they 
are sent to the client by hashing the body of each request, if necessary. This approach provides the 
flexibility to add or change response headers, body content, and other properties dynamically. By 
the end of the recipe, you will be able to develop custom middleware to control every API request.
Getting ready
Before we begin, please make sure you have completed the previous recipe, Creating custom 
ASGI middleware, to create specific custom ASGI middleware. We will be working on the 
middleware_project application, but the recipe can easily be applied to any application.
Before creating the middleware, in the main.py module, let’s create a POST /send endpoint that 
accepts body content in the request, as follows:
import logging
logger = logging.getLogger("uvicorn")
@app.post("/send")
async def send(message: str = Body()):
    logger.inf
Middleware and Webhooks
284
2.	
 Given that only certain HTTP verbs accept the body (POST and PUT, but not GET for example), 
we will pass to the middleware the paths as parameters where the modifications should be applied.
Create a middleware class called HashBodyContentMiddleware, as follows:
class HashBodyContentMiddleWare:
    def __init__(
        self, app: ASGIApp, allowed_paths: list[str]
    ):
        self.app = app
        self.allowed_paths = allowed_paths
We will pass the list of paths into the allowed_paths parameters.
3.	
Define the __call__ method of the class:
    async def __call__(
        self,
        scope: Scope,
        receive: Receive,
        send: Send,
    ):
        if (
            scope["type"] != "http"
            or scope["path"]
            not in self.allowed_paths
        ):
            await self.app(scope, receive, send)
            return
If the event is not an HTTP request or the path is not listed, the middleware won’t take any 
action and wil
Developing middleware for request modification
285
            )
            return message
        await self.app(
            scope,
            receive_with_new_body,
            send,
        )
The body request will be modified by the coroutine that is passed to the following steps of the 
FastAPI object application.
5.	
Now we need to add the middleware to the FastAPI instance. We can do it in the 
main.py module. But this time we will leverage the add_middleware method of the 
FastAPI instance object like this:
app.add_middleware(
    HashBodyContentMiddleWare,
    allowed_paths=["/send"],
)
Now the application will make the request pass through our middleware.
This is all you need to implement it. To test the middleware, let’s spin up the server with uvicorn 
from the command line by running the following:
$ uvicorn main:app
Then go to the interactive documentation at http://localhost:8000/docs and test the 
POST/send endpoint. For example, check whether you can send a body stri
Middleware and Webhooks
286
See also
Creating middleware to modify the request is documented on the Starlette documentation page:
•	 Inspecting or modifying the request: h t t p s : / / w w w . s t a r l e t t e . i o /
middleware/#inspecting-or-modifying-the-request
Developing middleware for response modification
Besides processing requests, middleware in web applications is also a powerful tool for processing 
responses. Custom middleware allows us to intercept responses before they are returned to the API 
caller. This can be useful for checking response content or personalizing the response. In this recipe, 
we will develop custom ASGI middleware to add customized headers to all the responses.
Getting ready
We will be creating custom ASGI middleware that modifies the response of each HTTP call. Before 
we get started on this recipe, take a look at the Creating custom ASGI middleware recipe. Also, this 
recipe will be complementary to the previous recipe, Developing middleware for r
Developing middleware for response modification
287
2.	
Then, we can start defining the ExtraHeadersResponseMiddleware middleware class 
as follows:
class ExtraHeadersResponseMiddleware:
    def __init__(
        self,
        app: ASGIApp,
        headers: Sequence[tuple[str, str]],
    ):
        self.app = app
        self.headers = headers
3.	
We will pass the headers list as an argument to the middleware. Then, the __call__ method 
will be as follows:
    async def __call__(
        self,
        scope: Scope,
        receive: Receive,
        send: Send,
    ):
        if scope["type"] != "http":
            return await self.app(
                scope, receive, send
            )
4.	
We restrain the middleware to HTTP event calls. Similar to what we saw in the previous recipe, 
Developing middleware for request modification, we modify the send object, which is a coroutine, 
and we pass it to the next middleware, as follows:
        async def send_with_extra_headers(
            
Middleware and Webhooks
288
        await self.app(
            scope, receive, send_with_extra_headers
        )
The response’s headers are generated from the message parameter of the send_with_
extra_headerds coroutine object.
5.	
Once the middleware is defined, we need to add it to the FastAPI object instance to make it 
effective. We can add it in the main.py module as follows:
app.add_middleware(
    ExtraHeadersResponseMiddleware,
    headers=(
        ("new-header", "fastapi-cookbook"),
        (
            "another-header",
            "fastapi-cookbook",
        ),
    ),
)
Here, we add two headers to the response, new-header and another-header. 
To test it, spin up the server by running uvicorn main:app and open the interactive 
documentation. Call one of the endpoints and check the headers in the response.
Here is the list of the headers you get when calling the GET / endpoint:
another-header: fastapi-cookbook
content-length: 28
content-type: application/json
date: Thu,23 M
Handling CORS with middleware
289
See also
In the Starlette documentation, you can find an example of how to create middleware that modifies 
the response:
•	 Inspecting or modifying the response: https://www.starlette.io/
middleware/#inspecting-or-modifying-the-response
Handling CORS with middleware
CORS is a security feature implemented in web browsers to prevent malicious websites from making 
unauthorized requests to APIs hosted on different origins. When building APIs, especially for public 
consumption, it’s crucial to handle CORS properly to ensure legitimate requests are served while 
unauthorized ones are blocked.
In this recipe, we will explore how to handle CORS using custom middleware in FastAPI. This approach 
allows us to deeply understand the CORS mechanism and gain flexibility in customizing the behavior 
to fit specific requirements.
Getting ready
We will apply the recipe to the middleware_project application. Make sure you have the FastAPI 
application running with at
Middleware and Webhooks
290
That means that the call has been blocked by the CORS policy.
Let’s start the recipe and see how to fix it.
How to do it…
In FastAPI, CORS can be handled with a dedicated CORSMiddleware class from the Starlette library.
Let’s add the middleware to our application in the main.py module:
from fastapi.middleware.cors import CORSMiddleware
# rest of the module
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)
Now, rerun the server, open cors_page.html again, and try to press the Send CORS Request 
button. This time, you see the response message directly on the page.
The allow_origins parameter specifies the host origin from which the CORS should be allowed. 
If allow_origins=[*], it means that any origin is allowed.
The allow_methods parameter specifies the HTTP methods that are allowed. By default, only GET 
is allowed, and if allow_methods=[*], it means that all methods are allowed.
Then, the a
Restricting incoming requests from hosts
291
You can also have a look at the Starlette documentation page:
•	 CORSMiddleware: https://www.starlette.io/middleware/#corsmiddleware
Restricting incoming requests from hosts
In modern web applications, security is paramount. One crucial aspect of security is ensuring that 
your application only processes requests from trusted sources. This practice helps to mitigate risks 
such as Domain Name System (DNS) rebinding attacks, where an attacker tricks a user’s browser 
into interacting with an unauthorized domain.
FastAPI provides middleware called TrustedHostMiddleware, which allows you to specify which 
hosts are considered trusted. Requests from any other hosts will be rejected. This recipe will guide 
you through setting up and using the TrustedHostMiddleware class to secure your FastAPI 
application by accepting requests only from specific hosts.
Getting ready
We will apply the recipe to the middleware_project application. The application 
Middleware and Webhooks
292
To retrieve the address of your machine within the local network, you can run ipconfig on Windows 
or ip addr on Linux or macOS.
From another device connected to the same local network as the machine running our FastAPI application 
(such as a smartphone), open a browser and enter http://<your local address>:8000. 
If everything is correctly set up, you will see the following message in the browser:
Invalid host header
While on the machine running the FastAPI server, you will see a log message like the following:
INFO: <client ip>:57312 - "GET / HTTP/1.1" 400 Bad Request
This is all you need to set up middleware to prevent your application from being reached by undesired hosts.
See also
You can learn more about TrustedHostMiddleware on the FastAPI documentation page:
•	 TrustedHostMiddleware: https://fastapi.tiangolo.com/advanced/
middleware/#trustedhostmiddleware
Since TrustedHostMiddleware is defined in the Starlette library, you can also find it in the 
S
Implementing webhooks
293
Getting ready
To set up the webhook for sending requests to the subscriber, we will use custom ASGI middleware. 
Please ensure that you have already followed the Creating custom ASGI middleware recipe. We will 
be continuing our work on the middleware_project API. However, you will find guidelines 
on how to implement your webhook that can be easily adapted to the specific needs of your project.
If you are starting a new project from scratch, make sure to install the fastapi package with 
uvicorn in your environment. You can do this using pip:
$ pip install fastapi uvicorn
Once you have the packages, we can start the recipe.
How to do it…
To build a webhook system in our API, we will need to do the following:
1.	
Set up the URL registration system.
2.	
Implement the webhook callbacks.
3.	
Document the webhook.
Let’s go through the implementation.
Setting up the URL registration system
A webhook call will send an HTTP request to the list of URLs registered to t
Middleware and Webhooks
294
2.	
Let’s pass the lifespan as an argument to the FastAPI object, as follows:
app = FastAPI(
    lifespan=lifespan,
# rest of the parameters
)
3.	
Then, we can create the endpoint to register the URL, as follows:
@app.post("/register-webhook-url")
async def add_webhook_url(
    request: Request, url: str = Body()
):
    if not url.startswith("http"):
        url = f"http://{url}"
    request.state.webhook_urls.append(url)
    return {"url added": url}
The endpoint will accept a text string in the body. If the http or https protocol is missing 
in the string, an "http://" string will be prepended to the URL before being stored.
You have just implemented the URL registration system. Now, let’s continue to implement the 
webhook callbacks.
Implementing the webhook callbacks
After setting up the registration system, we can begin creating the webhook’s calls. As previously 
stated, this particular webhook will alert subscribers for every API call. We’ll utilize t
Implementing webhooks
295
2.	
Then, we define a coroutine that will be used to make the requests to the subscriber URLs, 
as follows:
import logging
from httpx import AsyncClient
client = AsyncClient()
logger = logging.getLogger("uvicorn")
async def send_event_to_url(
    url: str, event: Event
):
    logger.info(f"Sending event to {url}")
    try:
        await client.post(
            f"{url}/fastapi-webhook",
            json=event.model_dump(),
        )
    except Exception as e:
        logger.error(
            "Error sending webhook event "
            f"to {url}: {e}"
        )
The client sends a request to the URL. If the request fails, a message is printed to the terminal.
3.	
We then define the middleware that will intercept the request. We start with the imports, 
as follows:
from asyncio import create_task
from datetime import datetime
from fastapi import Request
from starlette.types import (
    ASGIApp, Receive, Scope, Send,
)
We then add the WebhookSenderMiddleware cla
Middleware and Webhooks
296
        scope: Scope,
        receive: Receive,
        send: Send,
    ):
4.	
We will filter only the HTTP requests, as follows:
        if scope["type"] == "http":
            message = await receive()
            body = message.get("body", b"")
            request = Request(scope=scope)
5.	
We continue in the same __call__ function by defining the event object to pass to the 
webhook subscribers:
            event = Event(
                host=request.client.host,
                path=request.url.path,
                time=datetime.now().isoformat(),
                body=body,
            )
6.	
Then, we iterate the calls over the URLs by running the send_event_to_url coroutine, 
as follows:
            urls = request.state.webhook_urls
            for url in urls:
                await create_task(
                    send_event_to_url(url, event)
                )
7.	
We finalize the method by returning the modified receive function to the application:
 
Implementing webhooks
297
We have just defined the middleware that will make the calls.
8.	
Now we need to import the WebhookSenderMiddleWare middleware in the application. 
We can do this inside main.py as follows:
from middleware.webhook import (
WebhookSenderMiddleWare
)
# rest of the code
app.add_middleware(WebhookSenderMiddleWare)
The application will now include our middleware to handle the webhook callbacks.
That is all you need to implement a complete webhook within your FastAPI application.
Documenting the webhook
It is important to provide API users with documentation on how the webhook functions. FastAPI 
allows us to document a webhook in the OpenAPI documentation.
To accomplish this, you need to create a function with an empty body and declare it as a webhook 
endpoint. You can do it in main.py as well:
@app.webhooks.post("/fastapi-webhook")
def fastapi_webhook(event: Event):
    """_summary_
    Args:
        event (Event): Received event from webhook
        It contains 
Middleware and Webhooks
298
                {
                    "host": "127.0.0.1",
                    "path": "/send",
                    "time": "2024-05-22T14:24:28.847663",
                    "body": '"body content"',
                }
            ]
        }
    }
After starting the server with the uvicorn main:app command and opening the browser 
at h t t p : / / l o c a l h o s t : 8 0 0 0 / d o c s , you will find the documentation for 
POST /fastapi-webhook in the Webhook section. This documentation explains the call that 
the API will make to the provided URLs through the POST register-webhook-url endpoint.
How it works…
To test the webhook, you can set up a simple server running locally on a specific port. You can create 
one yourself or download the http_server.py file from the GitHub repository. This server will 
run on port 8080.
Once you have set up the server, you can run it from the command line:
$ python ./http_server.py
Leave the server running and make sure th
Implementing webhooks
299
There’s more…
While the basic implementation of webhooks is powerful, several advanced concepts and enhancements 
can make your webhook system more robust, secure, and efficient. Some of the most relevant ones 
are as follows:
•	 Authentication: To ensure that your API can securely communicate with a webhook endpoint, 
you can implement any sort of authentication, from API to OAuth.
•	 Retry mechanism: Webhooks rely on HTTP, which is not always reliable. There may be instances 
where the webhook delivery fails due to network issues, server downtime, or other transient 
errors. Implementing a retry mechanism ensures that webhook events are eventually delivered 
even if the initial attempt fails.
•	 Persistent storage: Storing webhook events in a database allows you to keep an audit trail, 
troubleshoot issues, and replay events if necessary. You can use SQLAlchemy, a SQL toolkit and 
object-relational mapping library for Python, to save webhook events in a rela

12
Deploying and Managing 
FastAPI Applications
In this chapter, we delve into the essential aspects of deploying and managing FastAPI applications. 
As you develop your FastAPI projects, understanding how to effectively run, secure, and scale them is 
crucial for ensuring performance and reliability in production environments. This chapter will equip 
you with the knowledge and tools needed to deploy your FastAPI applications seamlessly, leveraging 
various technologies and best practices.
You will learn how to utilize the FastAPI CLI to run your server efficiently, enabling HTTPS to 
secure your applications, and containerizing your FastAPI projects with Docker. Additionally, 
we will explore techniques for scaling your applications across multiple workers, packaging your 
applications for distribution, and deploying them on cloud platforms such as Railway. Each recipe 
in this chapter provides step-by-step instructions, practical examples, and insights into optimizing 
your deployme
Deploying and Managing FastAPI Applications
302
Technical requirements
This chapter is for advanced users who want to learn how to deploy their FastAPI applications on 
the cloud. If you are new to FastAPI or Python, you might want to check out the first two chapters 
of the book.
You can find the chapter’s code on GitHub here: https://github.com/PacktPublishing/
FastAPI-Cookbook/tree/main/Chapter12.
To manage dependencies and isolate the project, set up a virtual environment in the project root folder.
For the Running FastAPI applications in Docker containers and Running the server across multiple 
workers recipes, we will be using Docker. Make sure to install it on your machine.
Running the server with the FastAPI CLI
The FastAPI command-line interface (CLI) is a program that runs in the command line. You can use 
the $ fastapi command to run a FastAPI application, manage a FastAPI project, and do other 
things. This feature was added in version 0.111.0 recently.
In this recipe, we’l
Running the server with the FastAPI CLI
303
If you already have installed it, make sure to have the latest version of fastapi in your environment. 
You can do it by running the following:
$ pip install fastapi --upgrade
Once the installation or the upgrade is completed, we can start the recipe.
How to do it…
With your application set up, simply run the following from the command line:
$ fastapi dev
You will see detailed information printed on the terminal. Let’s check the most important ones.
The first message is like this:
INFO    Using path app\main.py
In the fastapi dev command, we didn’t specify an app.main:app argument as we used to do 
with the uvicorn command. The FastAPI CLI automatically detects the FastAPI object class in 
the code according to a set of default paths.
The following messages are about the building of the server by looking at the packages and modules 
to be considered. Then, it explicitly shows the resolved import for the FastAPI object class:
╭─ Python module 
Deploying and Managing FastAPI Applications
304
Then, you will see messages specifying the running mode with the main addresses similar to this one:
╭────────── FastAPI CLI - Development mode ───────────╮
│                                                     │
│  Serving at: http://127.0.0.1:8000                  │
│                                                     │
│  API docs: http://127.0.0.1:8000/docs               │
│                                                     │
│  Running in development mode, for production use:   │
│                                                     │
│  fastapi run                                        │
│                                                     │
╰─────────────────────────────────────────────────────╯
This message indicates that the application is operating in development mode.
This means that it will restart the server automatically when there are code updates, and the server 
will run on the local address 127.0.0.1.
You can altern
Enabling HTTPS on FastAPI applications
305
This is the equivalent of the following:
$ uvicorn app.main:app --host 0.0.0.0
Your application will now be visible to the hosting local network.
See also
You can check more on the functionalities of the FastAPI CLI on the official documentation page:
•	 FastAPI CLI: https://fastapi.tiangolo.com/fastapi-cli/
Enabling HTTPS on FastAPI applications
Web applications need security, and Hypertext Transfer Protocol Secure (HTTPS) is a basic way to 
secure communication between clients and servers.
HTTPS scrambles the data sent over the network, preventing unauthorized access and modification.
In this recipe, we will learn how to enable HTTPS on FastAPI applications for local testing. We’ll use 
mkcert to make a Secure Sockets Layer/Transport Layer Security (SSL/TLS) certificate for local 
development and give some advice for production deployment. By the end of the recipe, you’ll be able 
to protect your FastAPI application with HTTPS, improving its
Deploying and Managing FastAPI Applications
306
How to do it…
Let’s set up our certificates through the following steps.
1.	
Let’s start by allowing our browser to trust certificates created locally with mkcert. Run this 
simple command:
$ mkcert -install
You will get a message like this:
The local CA is now installed in the system trust store! ⚡
This command has added a local certificate in your operating system trust store so that your 
browsers will automatically accept it as a reliable source of certificates.
2.	
We can then create the certificates and the private key that the server will use for some domain 
ranges by running the following:
$ mkcert localhost 127.0.0.1
This command will generate two files: example.com+5-key.pem for the key and example.
com+5.pem for the certificate.
Warning
To ensure security, do not include certificates and keys in your Git history when you create 
them. Add the *.pem file extension to the .gitignore file
3.	
We will have to give the key and the 
Enabling HTTPS on FastAPI applications
307
You can fix this by adding automatic redirection to the HTTPS of the server by using a dedicated 
middleware provided by FastAPI. Change the main.py file as follows:
from fastapi import FastAPI
from fastapi.middleware.httpsredirect import (
    HTTPSRedirectMiddleware,
)
app = FastAPI(title="FastAPI Live Application")
app.add_middleware(HTTPSRedirectMiddleware)
# rest of the module
Then, restart the server. If you try to connect to localhost with an HTTP connection, (for 
example, http://localhost:443), it will automatically redirect you to an HTTPS connection, 
https://localhost. However, since it does not support port redirection, you have to specify 
port 443 anyway.
You have just enabled an HTTPS connection for your FastAPI application within the server. By enabling 
HTTPS for your FastAPI application, you have taken an important step toward enhancing web security 
and user experience. You can now enjoy the features of FastAPI with more co
Deploying and Managing FastAPI Applications
308
See also
The GitHub repository at the following link shows you more possibilities of mkcert: 
•	 mkcert: https://github.com/FiloSottile/mkcert
In the FastAPI official documentation, you can have a look at HTTPS functioning on the page: 
•	 About HTTPS: https://fastapi.tiangolo.com/deployment/https/
Instructions on how to run uvicorn in HTTPS mode can be found at the following link: 
•	 Running with HTTPS: https://www.uvicorn.org/deployment/#running-
with-https
You can find details on HTTPSRedirectMiddle on the official documentation page at this link:
•	  HTTPSRedirectMiddleware: https://fastapi.tiangolo.com/advanced/
middleware/#httpsredirectmiddleware
Running FastAPI applications in Docker containers
Docker is a useful tool that lets developers wrap applications with their dependencies into a container. 
This method makes sure that the application operates reliably in different environments, avoiding the 
common works on my machine issu
Running FastAPI applications in Docker containers
309
You can use the recipe for your applications or follow along with the Live Application application 
that we introduced in the first recipe, which we are using throughout the chapter.
How to do it…
It is not very complicated to run a simple FastAPI application in a Docker container. The process 
consists of three steps:
1.	
Create the Dockerfile.
2.	
Build the image.
3.	
Generate the container.
Then, you just have to run the container to have the application working.
Creating the Dockerfile
The Dockerfile contains the instructions needed to build the image from an operating system and 
the file we want to specify.
It is good practice to create a separate Dockerfile for the development environment. We will name it 
Dockerfile.dev and place it under the project root folder.
We start the file by specifying the base image, which will be as follows:
FROM python:3.10
This will pull an image from the Docker Hub, which already comes with Pyt
Deploying and Managing FastAPI Applications
310
Finally, we define the server startup instruction as follows:
CMD ["fastapi", "run", "app/main.py", "--port", "80"]
This is all we need to create our Dockerfile.dev file.
Building the image
Once we have Dockerfile.dev, we can build the image. We can do it by running the following 
from the command line at the project root folder level:
$ docker build -f Dockerfile.dev -t live-application .
Since we named our Dockerfile Dockerfile.dev, we should specify it in an argument. Once 
the build is finished, you can check that the image has been correctly built by running the following:
$ docker images live-application
You should see the details of the image on the output print like this:
REPOSITORY      TAG    IMAGE ID    CREATED        SIZE
live-application latest  7ada80a535c2 43 seconds ago 1.06GB
With the image built, we can proceed with creating the container creation.
Creating the container
To create the container and run it; simply run the
Running the server across multiple workers
311
See also
The Dockerfile can be used to specify several features of the image. Check the list of commands in 
the official documentation: 
•	 Dockerfile reference: https://docs.docker.com/reference/dockerfile/
Also, you can have a look at the Docker CLI documentation on the following page: 
•	 Docker: https://docs.docker.com/reference/cli/docker/
You can have a look at the FastAPI documentation page dedicated to the integration with Docker at 
this link: 
•	 FastAPI in Containers - Docker: https://fastapi.tiangolo.com/deployment/
docker/ 
Running the server across multiple workers
In high-traffic environments, running a FastAPI application with a single worker may not be sufficient 
to handle all incoming requests efficiently. To improve performance and ensure better resource use, 
you can run your FastAPI instance across multiple workers. This can be achieved using tools such 
as Gunicorn.
In this recipe, we will explore how to run a FastA
Deploying and Managing FastAPI Applications
312
logger = logging.getLogger("uvicorn")
# rest of the module
@app.get("/")
def read_root():
    logger.info(f"Processd by worker {getpid()}")
    return {"Hello": "World"}
Let’s add the gunicorn dependency in the requirements.txt file as follows:
fastapi
gunicorn
We will use gunicorn instead of uvicorn to run the server.
If you are on Linux or macOS, you simply install gunicorn in your environment like this:
$ pip install gunicorn
Then, run the server with four workers with the following command:
$ gunicorn app.main:app --workers 4 \
--worker-class uvicorn.workers.UvicornWorker
If you are on Windows, we will use Docker. In the Dockerfile.dev file, add the new CMD instruction 
below the existing one, which will be ignored:
CMD ["gunicorn",\
    "app.main:app",\
    "--bind", "0.0.0.0:80",\
    "--workers", "4",\
    "--worker-class",\
    "uvicorn.workers.UvicornWorker",\
    "--log-level", "debug"]
Then, build the Docker image with the foll
Running the server across multiple workers
313
After the server is running, open the browser on http://localhost:8000/docs and use the 
interactive documentation to make calls. On the terminal output, you will notice different PIDs that 
vary for each call.
This shows that Gunicorn can distribute the load among different processes, and you can take advantage 
of multiple CPU cores.
You have learned how to run a FastAPI app with Gunicorn and multiple workers, which can improve 
the performance and scalability of your web service. You can experiment with different settings and 
options to find the optimal configuration for your needs.
Important note
You can run multiple workers with Uvicorn as well. However, Uvicorn’s worker process 
management is not as advanced as Gunicorn’s at the moment.
There’s more…
One of the benefits of running Gunicorn with multiple workers is that it can handle more concurrent 
requests and improve the performance and availability of the web application. Howeve
Deploying and Managing FastAPI Applications
314
Deploying your FastAPI application on the cloud
Deploying your FastAPI application on the cloud is an essential step to make it accessible to users 
worldwide. In this recipe, we will demonstrate how to deploy a FastAPI application on Railway.
Railway is a versatile and user-friendly platform that enables developers to deploy, manage, and scale 
their applications with ease. By the end of the recipe, you will have a FastAPI application running on 
Railway, ready to serve users on the internet.
Getting started
Before we begin, ensure that you have already set up an application, as we will be deploying it on the 
cloud. The recipe will be applied to our Live Application, the basic application created in the 
Running the server with the FastAPI CLI recipe.
Also, put the project folder on GitHub, since it will be used as a reference for the deployment.
You will also need to set up an account at https://railway.app. The creation is straightfor
Deploying your FastAPI application on the cloud
315
Connecting the Git repository
Once the configuration file is set up, log in to Railway (https://railway.app/login) with your 
account and you will be redirected to your dashboard (https://railway.app/dashboard).
Then, click on the + New Project button at the top right of the screen. Once on the new page, choose 
the Deploy from Github repo option and select the repository that hosts your project. If you forked the 
FastAPI-Cookbook repository (https://github.com/PacktPublishing/FastAPI-
Cookbook), you can select it.
Then select Deploy now and wait for the deployment to set up. It will automatically create a new 
project with a fictional name. Mine, for example, is profound-enchantment.
Once finished, the deployment icon will appear on the project dashboard. By default, the deployment 
takes the name of the chosen GitHub repository. In my case, it’s FastAPI-Cookbook.
Configuring the deployment
When you click on the deployment icon, you
Deploying and Managing FastAPI Applications
316
Open the address in a new browser tab, and check the response. You should see the implemented response:
{
    "Hello": "World"
}
In your web browser’s address bar, you can see a lock icon, which indicates that the connection is 
secure and has a certificate. Usually, when you expose your service to the web, the hosting platform 
provides you with certificates.
You have just deployed your FastAPI application to be accessible on the World Wide Web. Now, users 
from all over the world can access your service.
There’s more…
To deploy your service, Railway creates an image and then a container to run your service. You can 
specify a custom image with a Dockerfile and it will be automatically detected.
See also
You can discover more about Railway services on the official documentation website: 
•	 Railway Docs: https://docs.railway.app/
You can check the official FastAPI template used for Railway at this link: 
•	 FastAPI Example: https://githu
Shipping FastAPI applications with Hatch
317
On the FastAPI website, you can check other examples for other cloud providers at the following link:
•	 Deploy FastAPI on Cloud Providers: https://fastapi.tiangolo.com/deployment/
cloud/
A useful tool is the Porter platform, which allows you to deploy your applications on different cloud 
services such as AWS, GCP, and Azure from one centralized platform. Have a look at this link:
•	 Deploy a FastAPI app: https://docs.porter.run/guides/fastapi/deploy-
fastapi
Shipping FastAPI applications with Hatch
Packaging and shipping a FastAPI application as a distributable package are essential for deploying 
and sharing your application efficiently.
Hatch is a modern Python project management tool that simplifies the packaging, versioning, 
and distribution process. In this recipe, we’ll explore how to use Hatch to build and ship a package 
containing a FastAPI application. This will ensure that your application is portable, easy to install, 
and mai
Deploying and Managing FastAPI Applications
318
How to do it…
We divide the process of shipping our FastAPI package into five steps:
1.	
Initialize the project.
2.	
Install dependencies.
3.	
Create the app.
4.	
Build the distribution.
5.	
Test the package.
Let’s start building our package.
Initializing the project
We start by creating our project by bootstrapping the structure. Let’s call our application FCA, which stands 
for FastAPI Cookbook Application. Let’s bootstrap our project by running the following command:
$ hatch new "FCA Server"
The command will create a project bootstrap under the fca-server folder as follows:
fca-server
├──src
│  └── fca_server
│      ├── __about__.py
│      └── __init__.py
├──tests
│  └── __init__.py
├──LICENSE.txt
├──README.md
└──pyproject.tomt
We can then directly use a virtual environment by entering the fca-server directory and running 
the following:
$ hatch shell
The command will automatically create a default virtual environment and activate it. 
Shipping FastAPI applications with Hatch
319
Verify that the environment is correctly activated by checking the Python executable. You do it by 
running the following:
$ python -c "import sys; print(sys.executable)"
The executable should come from the virtual environment called fca-server, which will present 
a path such as <virtual environment locations>\fca-server\Scripts\python.
This will give you information on the virtual environment that you can also provide to your integrated 
development environment (IDE) to work with the code.
You can exit from the shell by typing exit in the terminal. Also, you can run commands in the virtual 
environment without spawning the shell. For example, you can check the Python executable of the 
default environment by running the following:
$ hatch run python -c "import sys; print(sys.executable)"
We can now proceed to install the package dependencies in our environment.
Installing dependencies
Now that you have created a virtual environment, let’s 
Deploying and Managing FastAPI Applications
320
Let’s create the main.py module under the src/fca_server folder and initialize the APIRouter 
object with one endpoint like this:
from fastapi import APIRouter
app = APIRouter()
@app.get("/")
def read_root():
    return {
        "message":
        "Welcome to the FastAPI Cookbook Application!"
    }
Then, let’s import the router into the src/fca_server.__init__.py file as follows:
from fca_server.main import router
This will allow us to directly import the router from the fca_server package from an external project.
Building the distribution
Now that we have finalized the package, let’s leverage Hatch to build the package distribution.
We will generate the package in the form of a .tar.gz file by running the following:
$ hatch build -t sdist ../dist
It will generate the fca_server-0.0.1.tar.gz file placed outside of the project in a dist 
folder. We will then use the file in an external project.
Testing the package
Next, we will make a d
Shipping FastAPI applications with Hatch
321
On Windows, type this instead:
$ .venv\Scripts\activate
Install the fca_server package with pip:
$ pip install ..\dist\fca_server-0.0.1.tar.gz
Use the path where the fca_server-0.0.1.tar.gz file is.
Now, try to import the package.
Make a main.py file and import the router from the fca_server package:
from fastapi import FastAPI
from fca_server import router
app = FastAPI(
    title="Import FCA Server Application"
)
app.include_router(router)
Run the server from the command line:
$ fastapi run
Go to the interactive documentation at http://localhost:8000/docs and see the endpoint 
in the external package. You have just created a custom package and imported it into another project.
You have learned how to use Hatch to create and manage your Python projects with ease. This is a 
powerful tool that can save you time and effort and help you write better code. Now, you can experiment 
with different options and features of Hatch and see what else y
Deploying and Managing FastAPI Applications
322
To find the location of the config.toml file, you can run the following command in your terminal:
$ hatch config find
Hatch also lets you create the build of your package in a wheel format, which is a binary distribution 
format that is more efficient and compatible than the traditional source distribution.
Moreover, you can publish your package directly to the Python Package Index (PyPI), where other 
users can find and install it. Hatch makes it easy to share your code with the world.
See also
You can find more information about Hatch in the official documentation at 
•	 Hatch: https://hatch.pypa.io/latest/
We learned how to create a project bootstrap, but with Hatch, you can also initialize an existing project. 
Check out the documentation page: 
•	 Existing project: https://hatch.pypa.io/1.9/intro/#existing-project 
One of the greatest advantages of using Hatch is the flexibility of running the project for several virtual 
environment
Index
A
abstraction layers
creating  138, 139
Accept-Language request HTTP header  212
Alembic  145
Amazon S3  42
Amazon Web Services (AWS)  316
API endpoint
defining  12, 13
Postman  13
Swagger UI, using  13
testing  114-120
API key authentication
best practices  105
handling  103-105
API versioning  66, 67
approaches  68
reference link  69
application performance
optimizing  216-218
ASGI documentation
reference link  282
ASGI middleware
reference link  282
asynchronous data operations
handling  42-46
asynchronous programming  42
best practices, in FastAPI  46
Asynchronous Server Gateway 
Interface (ASGI)  277
Asyncio, with Elasticsearch
reference link  196
Azure Blob Storage  42
B
background tasks
implementing  222-224
bcrypt algorithm  78
binary JSON (BSON) format  32
C
Card Verification Values (CVV)  157
Certbot  307
certificate authority (CA)  307
certificate signing request (CSR)  307
chat functionality
implementing, with WebSockets  235-239
Chroma
URL  275
Cohere
FastAPI, integr
Index
324
Comodo  307
concurrency
versus data consistency  163, 164
config.toml file  321
Continuous Integration /Continuous 
Delivery (CI/CD) pipeline  132
CORS middleware
references  290
Create, Read, Update, Delete 
(CRUD) operations  28, 121
creating  52-57
implementing  141-144
in MongoDB  171-175
with SQLAlchemy  28, 29
Cross-Origin Resource Sharing (CORS)  277
handling, with middleware  289, 290
cross-site request forgery (CSRF)  108
cross-site scripting (XSS) attacks  108
CRUD operations, with SQLAlchemy
new user, creating  29
specific user, reading  29, 30
user, deleting  31, 32
user, updating  30, 31
custom ASGI middleware
creating  278-282
developing, for request 
modification  282-285
developing, for response 
modification  286-288
custom middleware
creating  209-211
custom validators  38
D
database connection
initializing  139
database migrations
working with  144-147
database models  28
data handling  23
data masking  183
data masking, layers
encryption at rest  188
encry
Index
325
Docker Engine  308
Dockerfile
creating  309, 310
reference link  311
Domain Name System (DNS)  291, 307
E
Elasticsearch
FastAPI, integrating with  189, 190
index, creating  191-193
setting up, in FastAPI application  190, 191
Elasticsearch indexes
reference link  196
Elasticsearch Python client
reference link  196
encryption at rest  188
encryption in transit  188
endpoint, to interact with RAG AI assistant
creating  272-274
documents, ingesting and 
vectorizing  270, 271
model chain, building  272
prompts, defining  268-270
errors and exceptions
handling  19-22
F
FastAPI  135, 249
connecting, with GraphQL  255-258
integrating, with Cohere  262-267
integrating, with Elasticsearch  189, 190
integrating, with gRPC  250-255
integrating, with LangChain  267, 268
used, for setting up MongoDB  168-170
WebSockets, setting up  226-228
FastAPI application
debugging, techniques  126, 127
debugging, with PDB  127, 128
debugging, with PyCharm  129, 130
debugging, with Visual Studio 
Code
Index
326
FastAPI Framework  24
FastAPI project
asynchronous programming, applying  9
automatic documentation  11
basics  8
creating  6-8
endpoints  10
features  9
routers  10, 11
server, running  11
FastAPI request files
reference link  42
FastAPI template, used for Railway
reference link  316
FastAPI Test Client
reference link  114
FastAPI testing tools
references  64
FastAPI, with Elasticsearch
query, building  194
fernet symmetric encryption  157
file downloads
managing  41, 42
working with  39, 40
file uploads
implementing  40, 41
working with  39, 40
file storage
managing  41, 42
fixtures, in Pytest
reference link  64
G
Generative Pre-trained 
Transformer (GPT)  262
GitHub repository  250
Google Cloud Platform (GCP)  316
Google Cloud Storage  42
GraphQL
FastAPI, connecting with  255-258
gRPC
FastAPI, integrating with  250-255
Gunicorn  311
benefits  313
URL  313
H
Hatch  317, 321
FastAPI applications, shipping  317-321
HatchURL  322
HTTP handshake  227
HTTPS functioning, FastAPI 
Index
327
J
Jinja2  238
Joblib
ML models, using with  259-262
JSON Web Token (JWT)  77
working with, for authentication  83-87
JWT Authorization  246
L
LangChain
FastAPI, integrating with  267, 268
reference link  275
Large Language Model (LLM)  267
Let’s Encrypt  307
Lifespan Events
reference link  262
localization (l10n)  211-216
Locust
references  133
logging system
implementing, into FastAPI 
application  123-125
logout functionality
handling  105-108
M
Machine Learning (ML) models  249
using, with Joblib  259-262
mapping object classes
creating  137
middleware
used, for handling CORS  289, 290
mkcert  305, 307
reference link  308
MongoDB
CRUD operations  171-175
indexes, working within  179-183
integrating, for NoSQL data storage  32-34
setting up, with FastAPI  168-170
MongoDB Compass GUI
download link  24
MongoDB, for NoSQL data storage
new user, creating  34
user, reading  34, 35
MongoDB Inc  169
MongoDB Model Relationships
reference link  179
MongoDB Shell
download link  24
Mo
Index
328
WebSocket connections, 
securing with  244-248
working with, for authentication  83-87
object-relational mapping 
(ORM)  23, 135, 299
OpenSSL  307
P
path parameters
working with  13-15
PDB debugger
used, for debugging FastAPI 
applications  127, 128
Personal Identifiable Information (PII)  183
Porter platform
reference link  317
PostgreSQL  140
Postman  13, 99, 227, 228, 231
process ID (PID) number  311
PyCharm
reference link  130
setting up  5
used, for debugging FastAPI 
applications  129, 130
Pydantic  15, 18
pydantic models  36
Pydantic validators
reference link  39
pyinstrument profiler
reference link  219
PyMongo documentation
reference link  35
Pyotp  100
pyproject.toml file
reference link  322
Python  24
Python libraries  249
Python logging
reference link  126
Python Package Index (PyPI)  322
Q
query parameters
working with  13-15
R
Railway  301, 314
URL  314
Railway services
reference link  316
rate limiting
implementing  219-222
Red Hat  299
Redis
used, for caching 
Index
329
REST APIs  249
RESTful API
testing  59-64
RESTful APIs  51
documenting, with Redoc  74, 75
documenting, with Swagger UI  74, 75
RESTful Endpoints
creating  57-59
Retrieval-Augmented Generation 
(RAG)  267
role-based access control (RBAC)  77, 188
setting up  88-93
S
scikit-learn documentation
reference link  262
Secure Sockets Layer/Transport Layer 
Security (SSL/TLS) certificate  305
semantic versioning  68
sensitive data
exposing, from NoSQL databases  183-188
securing, best practices  47-49
securing, in SQL databases  156-160
serialization
working with  36, 37
serialization concept  37, 38
server
running, across multiple workers  311-313
running, with FastAPI CLI  303, 304
session cookies
handling  105-108
Slowapi features
URL  222
software as a service (SaaS)  77
SQLAlchemy  25, 135
CRUD operations with  28, 29
database connection, initializing  139
mapping object classes, creating  137-139
reference link  28, 32
setting up  136
SQL database
connection, establishing  27, 
Index
330
third-party authentication
using  94-99
Ticket database  139
time-based one-time password (TOTP)  100
TOTP URI  101
transactions and concurrency
handling  160-165
Transport Layer Security (TLS)  188
TrustedHostMiddleware class
incoming requests, restricting 
from hosts  291, 292
references  292
U
unit tests
techniques, executing  120, 121
test coverage, checking  122
writing and running  113, 114
unit tests, with Pytest
references  122
URL registration system
setting up  293, 294
user registration
setting up  78-83
uvicorn command  304
uvicorn, in HTTPS mode
reference link  308
V
venv package  317
Visual Studio Code
setting up  5
used, for debugging FastAPI 
applications  128, 129
W
webhooks
advanced concepts and enhancements  299
callbacks, implementing  294-297
documenting  297, 298
implementing  292-298
references  299
URL registration system, setting up  293, 294
WebSocket
benchmarking  243
errors and exceptions, handling  232-234
message, sending and receiving 
over  228
www.packtpub.com
Subscribe to our online digital library for full access to over 7,000 books and videos, as well as 
industry leading tools to help you plan your personal development and advance your career. For more 
information, please visit our website.
Why subscribe?
•	 Spend less time learning and more time coding with practical eBooks and Videos from over 
4,000 industry professionals
•	 Improve your learning with Skill Plans built especially for you
•	 Get a free eBook or video every month
•	 Fully searchable for easy access to vital information
•	 Copy and paste, print, and bookmark content
Did you know that Packt offers eBook versions of every book published, with PDF and ePub files 
available? You can upgrade to the eBook version at packtpub.com and as a print book customer, you 
are entitled to a discount on the eBook copy. Get in touch with us at customercare@packtpub.
com for more details.
At www.packtpub.com, you can also read a collection of free technical articles, sign
Other Books You May Enjoy
If you enjoyed this book, you may be interested in these other books by Packt:
Hands-On Microservices with Django
Tieme Woldman
ISBN: 978-1-83546-852-4
•	 Understand the architecture of microservices and how Django implements it
•	 Build microservices that leverage community-standard components such as Celery, RabbitMQ, 
and Redis
•	 Test microservices and deploy them with Docker
•	 Enhance the security of your microservices for production readiness
•	 Boost microservice performance through caching
•	 Implement best practices to design and deploy high-performing microservices
333
Other Books You May Enjoy
Node.js for Beginners
Ulises Gascón
ISBN: 978-1-80324-517-1
•	 Build solid and secure Node.js applications from scratch
•	 Discover how to consume and publish npm packages effectively
•	 Master patterns for refactoring and evolving your applications over time
•	 Gain a deep understanding of essential web development principles, including HTTP, RESTful 
API design, JWT, authentication, authorization, and error handling
•	 Implement robust testing strategies to enhance the quality and reliability of your applications
•	 Deploy your Node.js applications to production environments using Docker and PM2
334
Packt is searching for authors like you
If you’re interested in becoming an author for Packt, please visit authors.packtpub.com and 
apply today. We have worked with thousands of developers and tech professionals, just like you, to 
help them share their insight with the global tech community. You can make a general application, 
apply for a specific hot topic that we are recruiting an author for, or submit your own idea.
Share Your Thoughts
Now you’ve finished FastAPI Cookbook, we’d love to hear your thoughts! If you purchased the book 
from Amazon, please click here to go straight to the Amazon review page 
for this book and share your feedback or leave a review on the site that you purchased it from.
Your review is important to us and the tech community and will help us make sure we’re delivering 
excellent quality content.
335
Download a free PDF copy of this book
Thanks for purchasing this book!
Do you like to read on the go but are unable to carry your print books everywhere?
Is your eBook purchase not compatible with the device of your choice?
Don’t worry, now with every Packt book you get a DRM-free PDF version of that book at no cost.
Read anywhere, any place, on any device. Search, copy, and paste code from your favorite technical 
books directly into your application. 
The perks don’t stop there, you can get exclusive access to discounts, newsletters, and great free content 
in your inbox daily
Follow these simple steps to get the benefits:
1.	
Scan the QR code or visit the link below
 
https://packt.link/free-ebook/978-1-80512-785-7
2.	
Submit your proof of purchase
3.	
That’s it! We’ll send your free PDF and other benefits to your email directly

